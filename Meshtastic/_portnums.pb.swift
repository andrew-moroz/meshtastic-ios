// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: portnums.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

///* 
///For any new 'apps' that run on the device or via sister apps on phones/PCs they should pick and use a
///unique 'portnum' for their application.
///
///If you are making a new app using meshtastic, please send in a pull request to add your 'portnum' to this
///master table.  PortNums should be assigned in the following range:
///
///0-63   Core Meshtastic use, do not use for third party apps
///64-127 Registered 3rd party apps, send in a pull request that adds a new entry to portnums.proto to 
///register your application
///256-511 Use one of these portnums for your private applications that you don't want to register publically
///1024-66559 Are reserved for use by IP tunneling (see FIXME for more information)
///
///All other values are reserved.
///
///Note: This was formerly a Type enum named 'typ' with the same id #
///
///We have change to this 'portnum' based scheme for specifying app handlers for particular payloads.  
///This change is backwards compatible by treating the legacy OPAQUE/CLEAR_TEXT values identically.
enum PortNum: SwiftProtobuf.Enum {
  typealias RawValue = Int

  ///* Deprecated: do not use in new code (formerly called OPAQUE)
  ///A message sent from a device outside of the mesh, in a form the mesh
  ///does not understand 
  ///NOTE: This must be 0, because it is documented in IMeshService.aidl to be so
  case unknownApp // = 0

  ///* a simple UTF-8 text message, which even the little micros in the mesh
  ///can understand and show on their screen eventually in some circumstances
  ///even signal might send messages in this form (see below)
  ///Formerly called CLEAR_TEXT 
  case textMessageApp // = 1

  ///* Reserved for built-in GPIO/example app.
  ///See remote_hardware.proto/HardwareMessage for details on the message sent/received to this port number
  case remoteHardwareApp // = 2

  ///* The built-in position messaging app.
  ///See Position for details on the message sent to this port number.
  case positionApp // = 3

  ///* The built-in user info app.
  ///See User for details on the message sent to this port number.
  case nodeinfoApp // = 4

  ///* Provides a 'ping' service that replies to any packet it receives.  Also this serves as a
  ///small example plugin.
  case replyApp // = 32

  ///* Private applications should use portnums >= 256.  To simplify initial development and testing you can use "PRIVATE_APP"
  ///in your code without needing to rebuild protobuf files (via bin/regin_protos.sh) 
  case privateApp // = 256

  ///* 1024-66559 Are reserved for use by IP tunneling (see FIXME for more information) 
  case ipTunnelApp // = 1024
  case UNRECOGNIZED(Int)

  init() {
    self = .unknownApp
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownApp
    case 1: self = .textMessageApp
    case 2: self = .remoteHardwareApp
    case 3: self = .positionApp
    case 4: self = .nodeinfoApp
    case 32: self = .replyApp
    case 256: self = .privateApp
    case 1024: self = .ipTunnelApp
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unknownApp: return 0
    case .textMessageApp: return 1
    case .remoteHardwareApp: return 2
    case .positionApp: return 3
    case .nodeinfoApp: return 4
    case .replyApp: return 32
    case .privateApp: return 256
    case .ipTunnelApp: return 1024
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension PortNum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [PortNum] = [
    .unknownApp,
    .textMessageApp,
    .remoteHardwareApp,
    .positionApp,
    .nodeinfoApp,
    .replyApp,
    .privateApp,
    .ipTunnelApp,
  ]
}

#endif  // swift(>=4.2)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension PortNum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_APP"),
    1: .same(proto: "TEXT_MESSAGE_APP"),
    2: .same(proto: "REMOTE_HARDWARE_APP"),
    3: .same(proto: "POSITION_APP"),
    4: .same(proto: "NODEINFO_APP"),
    32: .same(proto: "REPLY_APP"),
    256: .same(proto: "PRIVATE_APP"),
    1024: .same(proto: "IP_TUNNEL_APP"),
  ]
}
