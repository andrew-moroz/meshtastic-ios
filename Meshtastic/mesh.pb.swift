// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: mesh.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

///
/// Meshtastic protobufs
///
/// For more information on protobufs (and tools to use them with the language of your choice) see
/// https://developers.google.com/protocol-buffers/docs/proto3
///
/// We are not placing any of these defs inside a package, because if you do the
/// resulting nanopb version is super verbose package mesh.
///
/// Protobuf build instructions:
///
/// To build java classes for reading writing:
/// protoc -I=. --java_out /tmp mesh.proto
///
/// To generate Nanopb c code:
/// /home/kevinh/packages/nanopb-0.4.0-linux-x86/generator-bin/protoc --nanopb_out=/tmp -I=app/src/main/proto mesh.proto
///
/// Nanopb binaries available here: https://jpa.kapsi.fi/nanopb/download/ use nanopb 0.4.0

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
    struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
    typealias Version = _2
}

///
/// Note: these enum names must EXACTLY match the string used in the device
/// bin/build-all.sh script.
/// Because they will be used to find firmware filenames in the android app for OTA updates.
/// To match the old style filenames, _ is converted to -, p is converted to .
enum HardwareModel: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unset // = 0
    case tloraV2 // = 1
    case tloraV1 // = 2
    case tloraV211P6 // = 3
    case tbeam // = 4
    
    /// The original heltec WiFi_Lora_32_V2, which had battery voltage sensing hooked to GPIO 13 (see HELTEC_V2 for the new version).
    case heltecV20 // = 5
    case tbeam0P7 // = 6
    case tEcho // = 7
    case tloraV11P3 // = 8
    case rak4631 // = 9
    
    /// The new version of the heltec WiFi_Lora_32_V2 board that has battery sensing hooked to GPIO 37.  Sadly they did not update anything on the silkscreen to identify this board
    case heltecV21 // = 10
    
    /// Ancient heltec WiFi_Lora_32 board
    case heltecV1 // = 11
    
    ///
    /// Less common/prototype boards listed here (needs one more byte over the air)
    case loraRelayV1 // = 32
    case nrf52840Dk // = 33
    case ppr // = 34
    case genieblocks // = 35
    case nrf52Unknown // = 36
    case portduino // = 37
    
    ///
    /// The simulator built into the android app
    case androidSim // = 38
    
    ///
    /// Custom DIY device based on @NanoVHF schematics: https://github.com/NanoVHF/Meshtastic-DIY/tree/main/Schematics
    case diyV1 // = 39
    
    ///
    /// RAK WisBlock ESP32 core: https://docs.rakwireless.com/Product-Categories/WisBlock/RAK11200/Overview/
    case rak11200 // = 40
    
    ///
    /// B&Q Consulting Nano Edition G1: https://uniteng.com/wiki/doku.php?id=meshtastic:nano
    case nanoG1 // = 41
    
    ///
    /// Custom Disaster Radio esp32 v3 device https://github.com/sudomesh/disaster-radio/tree/master/hardware/board_esp32_v3
    case drDev // = 43
    
    ///
    /// Reserved ID For developing private Ports. These will show up in live traffic sparsely, so we can use a high number. Keep it within 8 bits.
    case privateHw // = 255
    case UNRECOGNIZED(Int)
    
    init() {
        self = .unset
    }
    
    init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unset
        case 1: self = .tloraV2
        case 2: self = .tloraV1
        case 3: self = .tloraV211P6
        case 4: self = .tbeam
        case 5: self = .heltecV20
        case 6: self = .tbeam0P7
        case 7: self = .tEcho
        case 8: self = .tloraV11P3
        case 9: self = .rak4631
        case 10: self = .heltecV21
        case 11: self = .heltecV1
        case 32: self = .loraRelayV1
        case 33: self = .nrf52840Dk
        case 34: self = .ppr
        case 35: self = .genieblocks
        case 36: self = .nrf52Unknown
        case 37: self = .portduino
        case 38: self = .androidSim
        case 39: self = .diyV1
        case 40: self = .rak11200
        case 41: self = .nanoG1
        case 43: self = .drDev
        case 255: self = .privateHw
        default: self = .UNRECOGNIZED(rawValue)
        }
    }
    
    var rawValue: Int {
        switch self {
        case .unset: return 0
        case .tloraV2: return 1
        case .tloraV1: return 2
        case .tloraV211P6: return 3
        case .tbeam: return 4
        case .heltecV20: return 5
        case .tbeam0P7: return 6
        case .tEcho: return 7
        case .tloraV11P3: return 8
        case .rak4631: return 9
        case .heltecV21: return 10
        case .heltecV1: return 11
        case .loraRelayV1: return 32
        case .nrf52840Dk: return 33
        case .ppr: return 34
        case .genieblocks: return 35
        case .nrf52Unknown: return 36
        case .portduino: return 37
        case .androidSim: return 38
        case .diyV1: return 39
        case .rak11200: return 40
        case .nanoG1: return 41
        case .drDev: return 43
        case .privateHw: return 255
        case .UNRECOGNIZED(let i): return i
        }
    }
    
}

#if swift(>=4.2)

extension HardwareModel: CaseIterable {
    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static var allCases: [HardwareModel] = [
        .unset,
        .tloraV2,
        .tloraV1,
        .tloraV211P6,
        .tbeam,
        .heltecV20,
        .tbeam0P7,
        .tEcho,
        .tloraV11P3,
        .rak4631,
        .heltecV21,
        .heltecV1,
        .loraRelayV1,
        .nrf52840Dk,
        .ppr,
        .genieblocks,
        .nrf52Unknown,
        .portduino,
        .androidSim,
        .diyV1,
        .rak11200,
        .nanoG1,
        .drDev,
        .privateHw,
    ]
}

#endif  // swift(>=4.2)

///
/// The team colors are based on the names of "friendly teams" in ATAK:
/// https://github.com/deptofdefense/AndroidTacticalAssaultKit-CIV/blob/master/atak/ATAK/app/src/main/assets/filters/team_filters.xml
enum Team: SwiftProtobuf.Enum {
    typealias RawValue = Int
    
    /// the default (unset) is "achromatic" (unaffiliated)
    case clear // = 0
    case cyan // = 1
    case white // = 2
    case yellow // = 3
    case orange // = 4
    case magenta // = 5
    case red // = 6
    case maroon // = 7
    case purple // = 8
    case darkBlue // = 9
    case blue // = 10
    case teal // = 11
    case green // = 12
    case darkGreen // = 13
    case brown // = 14
    case UNRECOGNIZED(Int)
    
    init() {
        self = .clear
    }
    
    init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .clear
        case 1: self = .cyan
        case 2: self = .white
        case 3: self = .yellow
        case 4: self = .orange
        case 5: self = .magenta
        case 6: self = .red
        case 7: self = .maroon
        case 8: self = .purple
        case 9: self = .darkBlue
        case 10: self = .blue
        case 11: self = .teal
        case 12: self = .green
        case 13: self = .darkGreen
        case 14: self = .brown
        default: self = .UNRECOGNIZED(rawValue)
        }
    }
    
    var rawValue: Int {
        switch self {
        case .clear: return 0
        case .cyan: return 1
        case .white: return 2
        case .yellow: return 3
        case .orange: return 4
        case .magenta: return 5
        case .red: return 6
        case .maroon: return 7
        case .purple: return 8
        case .darkBlue: return 9
        case .blue: return 10
        case .teal: return 11
        case .green: return 12
        case .darkGreen: return 13
        case .brown: return 14
        case .UNRECOGNIZED(let i): return i
        }
    }
    
}

#if swift(>=4.2)

extension Team: CaseIterable {
    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static var allCases: [Team] = [
        .clear,
        .cyan,
        .white,
        .yellow,
        .orange,
        .magenta,
        .red,
        .maroon,
        .purple,
        .darkBlue,
        .blue,
        .teal,
        .green,
        .darkGreen,
        .brown,
    ]
}

#endif  // swift(>=4.2)

///
/// Shared constants between device and phone
enum Constants: SwiftProtobuf.Enum {
    typealias RawValue = Int
    
    ///
    /// First enum must be zero, and we are just using this enum to
    /// pass int constants between two very different environments
    case unused // = 0
    
    ///
    /// From mesh.options
    /// note: this payload length is ONLY the bytes that are sent inside of the Data protobuf (excluding protobuf overhead). The 16 byte header is
    /// outside of this envelope
    case dataPayloadLen // = 237
    case UNRECOGNIZED(Int)
    
    init() {
        self = .unused
    }
    
    init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unused
        case 237: self = .dataPayloadLen
        default: self = .UNRECOGNIZED(rawValue)
        }
    }
    
    var rawValue: Int {
        switch self {
        case .unused: return 0
        case .dataPayloadLen: return 237
        case .UNRECOGNIZED(let i): return i
        }
    }
    
}

#if swift(>=4.2)

extension Constants: CaseIterable {
    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static var allCases: [Constants] = [
        .unused,
        .dataPayloadLen,
    ]
}

#endif  // swift(>=4.2)

///
/// Error codes for critical errors
///
/// The device might report these fault codes on the screen.
/// If you encounter a fault code, please post on the meshtastic.discourse.group
/// and we'll try to help.
enum CriticalErrorCode: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case none // = 0
    
    ///
    /// A software bug was detected while trying to send lora
    case txWatchdog // = 1
    
    ///
    /// A software bug was detected on entry to sleep
    case sleepEnterWait // = 2
    
    ///
    /// No Lora radio hardware could be found
    case noRadio // = 3
    
    ///
    /// Not normally used
    case unspecified // = 4
    
    ///
    /// We failed while configuring a UBlox GPS
    case ubloxInitFailed // = 5
    
    ///
    /// This board was expected to have a power management chip and it is missing or broken
    case noAxp192 // = 6
    
    ///
    /// The channel tried to set a radio setting which is not supported by this chipset,
    /// radio comms settings are now undefined.
    case invalidRadioSetting // = 7
    
    ///
    /// Radio transmit hardware failure. We sent data to the radio chip, but it didn't
    /// reply with an interrupt.
    case transmitFailed // = 8
    
    ///
    /// We detected that the main CPU voltage dropped below the minumum acceptable value
    case brownout // = 9
    
    /// Selftest of SX1262 radio chip failed
    case sx1262Failure // = 10
    
    /// A (likely software but possibly hardware) failure was detected while trying to send packets. If this occurs on your board, please
    ///post in the forum so that we can ask you to collect some information to allow fixing this bug
    case radioSpiBug // = 11
    case UNRECOGNIZED(Int)
    
    init() {
        self = .none
    }
    
    init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .none
        case 1: self = .txWatchdog
        case 2: self = .sleepEnterWait
        case 3: self = .noRadio
        case 4: self = .unspecified
        case 5: self = .ubloxInitFailed
        case 6: self = .noAxp192
        case 7: self = .invalidRadioSetting
        case 8: self = .transmitFailed
        case 9: self = .brownout
        case 10: self = .sx1262Failure
        case 11: self = .radioSpiBug
        default: self = .UNRECOGNIZED(rawValue)
        }
    }
    
    var rawValue: Int {
        switch self {
        case .none: return 0
        case .txWatchdog: return 1
        case .sleepEnterWait: return 2
        case .noRadio: return 3
        case .unspecified: return 4
        case .ubloxInitFailed: return 5
        case .noAxp192: return 6
        case .invalidRadioSetting: return 7
        case .transmitFailed: return 8
        case .brownout: return 9
        case .sx1262Failure: return 10
        case .radioSpiBug: return 11
        case .UNRECOGNIZED(let i): return i
        }
    }
    
}

#if swift(>=4.2)

extension CriticalErrorCode: CaseIterable {
    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static var allCases: [CriticalErrorCode] = [
        .none,
        .txWatchdog,
        .sleepEnterWait,
        .noRadio,
        .unspecified,
        .ubloxInitFailed,
        .noAxp192,
        .invalidRadioSetting,
        .transmitFailed,
        .brownout,
        .sx1262Failure,
        .radioSpiBug,
    ]
}

#endif  // swift(>=4.2)

///
/// a gps position
struct Position {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    ///
    /// The new preferred location encoding, divide by 1e-7 to get degrees
    /// in floating point
    var latitudeI: Int32 {
        get {return _storage._latitudeI}
        set {_uniqueStorage()._latitudeI = newValue}
    }
    
    var longitudeI: Int32 {
        get {return _storage._longitudeI}
        set {_uniqueStorage()._longitudeI = newValue}
    }
    
    ///
    /// In meters above MSL (but see issue #359)
    var altitude: Int32 {
        get {return _storage._altitude}
        set {_uniqueStorage()._altitude = newValue}
    }
    
    ///
    /// 1-100 (0 means not provided)
    var batteryLevel: Int32 {
        get {return _storage._batteryLevel}
        set {_uniqueStorage()._batteryLevel = newValue}
    }
    
    ///
    /// This is usually not sent over the mesh (to save space), but it is sent
    /// from the phone so that the local device can set its RTC If it is sent over
    /// the mesh (because there are devices on the mesh without GPS), it will only
    /// be sent by devices which has a hardware GPS clock.
    /// seconds since 1970
    var time: UInt32 {
        get {return _storage._time}
        set {_uniqueStorage()._time = newValue}
    }
    
    var locationSource: Position.LocSource {
        get {return _storage._locationSource}
        set {_uniqueStorage()._locationSource = newValue}
    }
    
    var altitudeSource: Position.AltSource {
        get {return _storage._altitudeSource}
        set {_uniqueStorage()._altitudeSource = newValue}
    }
    
    ///
    /// Positional timestamp (actual timestamp of GPS solution) in integer epoch seconds
    var posTimestamp: UInt32 {
        get {return _storage._posTimestamp}
        set {_uniqueStorage()._posTimestamp = newValue}
    }
    
    ///
    /// Pos. timestamp milliseconds adjustment (rarely available or required)
    var posTimeMillis: Int32 {
        get {return _storage._posTimeMillis}
        set {_uniqueStorage()._posTimeMillis = newValue}
    }
    
    ///
    /// HAE altitude in meters - can be used instead of MSL altitude
    var altitudeHae: Int32 {
        get {return _storage._altitudeHae}
        set {_uniqueStorage()._altitudeHae = newValue}
    }
    
    ///
    /// Geoidal separation in meters
    var altGeoidSep: Int32 {
        get {return _storage._altGeoidSep}
        set {_uniqueStorage()._altGeoidSep = newValue}
    }
    
    ///
    /// Horizontal, Vertical and Position Dilution of Precision, in 1/100 units
    /// - PDOP is sufficient for most cases
    /// - for higher precision scenarios, HDOP and VDOP can be used instead,
    ///   in which case PDOP becomes redundant (PDOP=sqrt(HDOP^2 + VDOP^2))
    var pdop: UInt32 {
        get {return _storage._pdop}
        set {_uniqueStorage()._pdop = newValue}
    }
    
    var hdop: UInt32 {
        get {return _storage._hdop}
        set {_uniqueStorage()._hdop = newValue}
    }
    
    var vdop: UInt32 {
        get {return _storage._vdop}
        set {_uniqueStorage()._vdop = newValue}
    }
    
    ///
    /// GPS accuracy (a hardware specific constant) in mm
    ///   multiplied with DOP to calculate positional accuracy
    /// Default: "'bout three meters-ish" :)
    var gpsAccuracy: UInt32 {
        get {return _storage._gpsAccuracy}
        set {_uniqueStorage()._gpsAccuracy = newValue}
    }
    
    ///
    /// Ground speed in m/s and True North TRACK in 1/100 degrees
    ///
    /// Clarification of terms:
    /// - "track" is the direction of motion (measured in horizontal plane)
    /// - "heading" is where the fuselage points (measured in horizontal plane)
    /// - "yaw" indicates a relative rotation about the vertical axis
    var groundSpeed: UInt32 {
        get {return _storage._groundSpeed}
        set {_uniqueStorage()._groundSpeed = newValue}
    }
    
    var groundTrack: UInt32 {
        get {return _storage._groundTrack}
        set {_uniqueStorage()._groundTrack = newValue}
    }
    
    ///
    /// GPS fix quality (from NMEA GxGGA statement or similar)
    var fixQuality: UInt32 {
        get {return _storage._fixQuality}
        set {_uniqueStorage()._fixQuality = newValue}
    }
    
    ///
    /// GPS fix type 2D/3D (from NMEA GxGSA statement)
    var fixType: UInt32 {
        get {return _storage._fixType}
        set {_uniqueStorage()._fixType = newValue}
    }
    
    ///
    /// GPS "Satellites in View" number
    var satsInView: UInt32 {
        get {return _storage._satsInView}
        set {_uniqueStorage()._satsInView = newValue}
    }
    
    ///
    /// Sensor ID - in case multiple positioning sensors are being used
    var sensorID: UInt32 {
        get {return _storage._sensorID}
        set {_uniqueStorage()._sensorID = newValue}
    }
    
    ///
    /// Estimated/expected time (in seconds) until next update:
    /// - if we update at fixed intervals of X seconds, use X
    /// - if we update at dynamic intervals (based on relative movement etc),
    ///   but "AT LEAST every Y seconds", use Y
    var posNextUpdate: UInt32 {
        get {return _storage._posNextUpdate}
        set {_uniqueStorage()._posNextUpdate = newValue}
    }
    
    ///
    /// A sequence number, incremented with each Position message to help
    ///   detect lost updates if needed
    var posSeqNumber: UInt32 {
        get {return _storage._posSeqNumber}
        set {_uniqueStorage()._posSeqNumber = newValue}
    }
    
    var unknownFields = SwiftProtobuf.UnknownStorage()
    
    ///
    /// How the location was acquired: manual, onboard GPS, external (EUD) GPS
    enum LocSource: SwiftProtobuf.Enum {
        typealias RawValue = Int
        case locsrcUnspecified // = 0
        case locsrcManualEntry // = 1
        case locsrcGpsInternal // = 2
        
        ///
        /// More location sources can be added here when available:
        ///   GSM, radio beacons (BLE etc), location fingerprinting etc
        case locsrcGpsExternal // = 3
        case UNRECOGNIZED(Int)
        
        init() {
            self = .locsrcUnspecified
        }
        
        init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .locsrcUnspecified
            case 1: self = .locsrcManualEntry
            case 2: self = .locsrcGpsInternal
            case 3: self = .locsrcGpsExternal
            default: self = .UNRECOGNIZED(rawValue)
            }
        }
        
        var rawValue: Int {
            switch self {
            case .locsrcUnspecified: return 0
            case .locsrcManualEntry: return 1
            case .locsrcGpsInternal: return 2
            case .locsrcGpsExternal: return 3
            case .UNRECOGNIZED(let i): return i
            }
        }
        
    }
    
    ///
    /// How the altitude was acquired: manual, GPS int/ext, etc
    /// Default: same as location_source if present
    enum AltSource: SwiftProtobuf.Enum {
        typealias RawValue = Int
        case altsrcUnspecified // = 0
        case altsrcManualEntry // = 1
        case altsrcGpsInternal // = 2
        case altsrcGpsExternal // = 3
        case altsrcBarometric // = 4
        case UNRECOGNIZED(Int)
        
        init() {
            self = .altsrcUnspecified
        }
        
        init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .altsrcUnspecified
            case 1: self = .altsrcManualEntry
            case 2: self = .altsrcGpsInternal
            case 3: self = .altsrcGpsExternal
            case 4: self = .altsrcBarometric
            default: self = .UNRECOGNIZED(rawValue)
            }
        }
        
        var rawValue: Int {
            switch self {
            case .altsrcUnspecified: return 0
            case .altsrcManualEntry: return 1
            case .altsrcGpsInternal: return 2
            case .altsrcGpsExternal: return 3
            case .altsrcBarometric: return 4
            case .UNRECOGNIZED(let i): return i
            }
        }
        
    }
    
    init() {}
    
    fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Position.LocSource: CaseIterable {
    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static var allCases: [Position.LocSource] = [
        .locsrcUnspecified,
        .locsrcManualEntry,
        .locsrcGpsInternal,
        .locsrcGpsExternal,
    ]
}

extension Position.AltSource: CaseIterable {
    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static var allCases: [Position.AltSource] = [
        .altsrcUnspecified,
        .altsrcManualEntry,
        .altsrcGpsInternal,
        .altsrcGpsExternal,
        .altsrcBarometric,
    ]
}

#endif  // swift(>=4.2)

///
/// Broadcast when a newly powered mesh node wants to find a node num it can use
/// Sent from the phone over bluetooth to set the user id for the owner of this node.
/// Also sent from nodes to each other when a new node signs on (so all clients can have this info)
///
/// The algorithm is as follows:
/// when a node starts up, it broadcasts their user and the normal flow is for all
/// other nodes to reply with their User as well (so the new node can build its nodedb)
/// If a node ever receives a User (not just the first broadcast) message where
/// the sender node number equals our node number, that indicates a collision has
/// occurred and the following steps should happen:
///
/// If the receiving node (that was already in the mesh)'s macaddr is LOWER than the
/// new User who just tried to sign in: it gets to keep its nodenum.
/// We send a broadcast message of OUR User (we use a broadcast so that the other node can
/// receive our message, considering we have the same id - it also serves to let
/// observers correct their nodedb) - this case is rare so it should be okay.
///
/// If any node receives a User where the macaddr is GTE than their local macaddr,
/// they have been vetoed and should pick a new random nodenum (filtering against
/// whatever it knows about the nodedb) and rebroadcast their User.
///
/// A few nodenums are reserved and will never be requested:
/// 0xff - broadcast
/// 0 through 3 - for future use
struct User {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    ///
    /// A globally unique ID string for this user.
    /// In the case of Signal that would mean +16504442323, for the default macaddr derived id it would be !<8 hexidecimal bytes>.
    /// Note: app developers are encouraged to also use the following standard
    /// node IDs "^all" (for broadcast), "^local" (for the locally connected node)
    var id: String = String()
    
    ///
    /// A full name for this user, i.e. "Kevin Hester"
    var longName: String = String()
    
    ///
    /// A VERY short name, ideally two characters.
    /// Suitable for a tiny OLED screen
    var shortName: String = String()
    
    ///
    /// This is the addr of the radio.
    /// Not populated by the phone, but added by the esp32 when broadcasting
    var macaddr: Data = Data()
    
    ///
    /// TBEAM, HELTEC, etc...
    /// Starting in 1.2.11 moved to hw_model enum in the NodeInfo object.
    /// Apps will still need the string here for older builds
    /// (so OTA update can find the right image), but if the enum is available it will be used instead.
    var hwModel: HardwareModel = .unset
    
    ///
    /// In some regions Ham radio operators have different bandwidth limitations than others.
    /// If this user is a licensed operator, set this flag.
    /// Also, "long_name" should be their licence number.
    var isLicensed: Bool = false
    
    ///
    /// Participants in the same network can self-group into different teams.
    /// Short-term this can be used to visually differentiate them on the map;
    /// in the longer term it could also help users to semi-automatically
    /// select or ignore messages according to team affiliation.
    /// In total, 14 teams are defined (encoded in 4 bits)
    var team: Team = .clear
    
    ///
    /// Transmit power at antenna connector, in decibel-milliwatt
    /// An optional self-reported value useful in network planning, discovery
    /// and positioning - along with ant_gain_dbi and ant_azimuth below
    var txPowerDbm: UInt32 = 0
    
    ///
    /// Antenna gain (applicable to both Tx and Rx), in decibel-isotropic
    var antGainDbi: UInt32 = 0
    
    ///
    /// Directional antenna true azimuth *if applicable*, in degrees (0-360)
    /// Only applicable in case of stationary nodes with a directional antenna
    /// Zero = not applicable (mobile or omni) or not specified
    /// (use a value of 360 to indicate an antenna azimuth of zero degrees)
    var antAzimuth: UInt32 = 0
    
    var unknownFields = SwiftProtobuf.UnknownStorage()
    
    init() {}
}

///
/// A message used in our Dynamic Source Routing protocol (RFC 4728 based)
struct RouteDiscovery {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    ///
    /// The list of nodenums this packet has visited so far
    var route: [UInt32] = []
    
    var unknownFields = SwiftProtobuf.UnknownStorage()
    
    init() {}
}

///
/// A Routing control Data packet handled by the routing plugin
struct Routing {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    var variant: Routing.OneOf_Variant? = nil
    
    ///
    /// A route request going from the requester
    var routeRequest: RouteDiscovery {
        get {
            if case .routeRequest(let v)? = variant {return v}
            return RouteDiscovery()
        }
        set {variant = .routeRequest(newValue)}
    }
    
    ///
    /// A route reply
    var routeReply: RouteDiscovery {
        get {
            if case .routeReply(let v)? = variant {return v}
            return RouteDiscovery()
        }
        set {variant = .routeReply(newValue)}
    }
    
    ///
    /// A failure in delivering a message (usually used for routing control messages, but might be provided
    /// in addition to ack.fail_id to provide details on the type of failure).
    var errorReason: Routing.Error {
        get {
            if case .errorReason(let v)? = variant {return v}
            return .none
        }
        set {variant = .errorReason(newValue)}
    }
    
    var unknownFields = SwiftProtobuf.UnknownStorage()
    
    enum OneOf_Variant: Equatable {
        ///
        /// A route request going from the requester
        case routeRequest(RouteDiscovery)
        ///
        /// A route reply
        case routeReply(RouteDiscovery)
        ///
        /// A failure in delivering a message (usually used for routing control messages, but might be provided
        /// in addition to ack.fail_id to provide details on the type of failure).
        case errorReason(Routing.Error)
        
#if !swift(>=4.1)
        static func ==(lhs: Routing.OneOf_Variant, rhs: Routing.OneOf_Variant) -> Bool {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch (lhs, rhs) {
            case (.routeRequest, .routeRequest): return {
                guard case .routeRequest(let l) = lhs, case .routeRequest(let r) = rhs else { preconditionFailure() }
                return l == r
            }()
            case (.routeReply, .routeReply): return {
                guard case .routeReply(let l) = lhs, case .routeReply(let r) = rhs else { preconditionFailure() }
                return l == r
            }()
            case (.errorReason, .errorReason): return {
                guard case .errorReason(let l) = lhs, case .errorReason(let r) = rhs else { preconditionFailure() }
                return l == r
            }()
            default: return false
            }
        }
#endif
    }
    
    ///
    /// A failure in delivering a message (usually used for routing control messages, but might be provided in addition to ack.fail_id to provide
    /// details on the type of failure).
    enum Error: SwiftProtobuf.Enum {
        typealias RawValue = Int
        
        ///
        /// This message is not a failure
        case none // = 0
        
        ///
        /// Our node doesn't have a route to the requested destination anymore.
        case noRoute // = 1
        
        ///
        /// We received a nak while trying to forward on your behalf
        case gotNak // = 2
        case timeout // = 3
        
        ///
        /// No suitable interface could be found for delivering this packet
        case noInterface // = 4
        
        ///
        /// We reached the max retransmission count (typically for naive flood routing)
        case maxRetransmit // = 5
        
        ///
        /// No suitable channel was found for sending this packet (i.e. was requested channel index disabled?)
        case noChannel // = 6
        
        ///
        /// The packet was too big for sending (exceeds interface MTU after encoding)
        case tooLarge // = 7
        
        ///
        /// The request had want_response set, the request reached the destination node, but no service on that node wants to send a response
        /// (possibly due to bad channel permissions)
        case noResponse // = 8
        
        ///
        /// The application layer service on the remote node received your request, but considered your request somehow invalid
        case badRequest // = 32
        
        ///
        /// The application layer service on the remote node received your request, but considered your request not authorized (i.e you did not
        /// send the request on the required bound channel)
        case notAuthorized // = 33
        case UNRECOGNIZED(Int)
        
        init() {
            self = .none
        }
        
        init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .none
            case 1: self = .noRoute
            case 2: self = .gotNak
            case 3: self = .timeout
            case 4: self = .noInterface
            case 5: self = .maxRetransmit
            case 6: self = .noChannel
            case 7: self = .tooLarge
            case 8: self = .noResponse
            case 32: self = .badRequest
            case 33: self = .notAuthorized
            default: self = .UNRECOGNIZED(rawValue)
            }
        }
        
        var rawValue: Int {
            switch self {
            case .none: return 0
            case .noRoute: return 1
            case .gotNak: return 2
            case .timeout: return 3
            case .noInterface: return 4
            case .maxRetransmit: return 5
            case .noChannel: return 6
            case .tooLarge: return 7
            case .noResponse: return 8
            case .badRequest: return 32
            case .notAuthorized: return 33
            case .UNRECOGNIZED(let i): return i
            }
        }
        
    }
    
    init() {}
}

#if swift(>=4.2)

extension Routing.Error: CaseIterable {
    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static var allCases: [Routing.Error] = [
        .none,
        .noRoute,
        .gotNak,
        .timeout,
        .noInterface,
        .maxRetransmit,
        .noChannel,
        .tooLarge,
        .noResponse,
        .badRequest,
        .notAuthorized,
    ]
}

#endif  // swift(>=4.2)

///
/// (Formerly called SubPacket)
/// The payload portion fo a packet, this is the actual bytes that are sent
/// inside a radio packet (because from/to are broken out by the comms library)
struct DataMessage {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    ///
    /// Formerly named typ and of type Type
    var portnum: PortNum = .unknownApp
    
    ///
    /// Required
    var payload: Data = Data()
    
    ///
    /// Not normally used, but for testing a sender can request that recipient
    /// responds in kind (i.e. if it received a position, it should unicast back it's position).
    /// Note: that if you set this on a broadcast you will receive many replies.
    var wantResponse: Bool = false
    
    ///
    /// The address of the destination node.
    /// This field is is filled in by the mesh radio device software, application
    /// layer software should never need it.
    /// RouteDiscovery messages _must_ populate this.
    /// Other message types might need to if they are doing multihop routing.
    var dest: UInt32 = 0
    
    ///
    /// The address of the original sender for this message.
    /// This field should _only_ be populated for reliable multihop packets (to keep
    /// packets small).
    var source: UInt32 = 0
    
    ///
    /// Only used in routing or response messages.
    /// Indicates the original message ID that this message is reporting failure on. (formerly called original_id)
    var requestID: UInt32 = 0
    
    ///
    /// If set, this message is intened to be a reply to a previously sent message with the defined id.
    var replyID: UInt32 = 0
    
    ///
    /// Defaults to false. If true, then what is in the payload should be treated as an emoji like giving
    /// a message a heart or poop emoji.
    var isTapback: Bool = false
    
    var unknownFields = SwiftProtobuf.UnknownStorage()
    
    init() {}
}

///
/// A packet envelope sent/received over the mesh
/// only payloadVariant is sent in the payload portion of the LORA packet.
/// The other fields are either not sent at all, or sent in the special 16 byte LORA header.
struct MeshPacket {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    ///
    /// The sending node number.
    /// Note: Our crypto implementation uses this field as well.
    /// See [crypto](/developers/device/encryption.md) for details.
    /// FIXME - really should be fixed32 instead, this encoding only hurts the ble link though.
    var from: UInt32 {
        get {return _storage._from}
        set {_uniqueStorage()._from = newValue}
    }
    
    ///
    /// The (immediatSee Priority description for more details.y should be fixed32 instead, this encoding only
    /// hurts the ble link though.
    var to: UInt32 {
        get {return _storage._to}
        set {_uniqueStorage()._to = newValue}
    }
    
    ///
    /// (Usually) If set, this indicates the index in the secondary_channels table that this packet was sent/received on.
    /// If unset, packet was on the primary channel.
    /// A particular node might know only a subset of channels in use on the mesh.
    /// Therefore channel_index is inherently a local concept and meaningless to send between nodes.
    /// Very briefly, while sending and receiving deep inside the device Router code, this field instead
    /// contains the 'channel hash' instead of the index.
    /// This 'trick' is only used while the payloadVariant is an 'encrypted'.
    var channel: UInt32 {
        get {return _storage._channel}
        set {_uniqueStorage()._channel = newValue}
    }
    
    var payloadVariant: OneOf_PayloadVariant? {
        get {return _storage._payloadVariant}
        set {_uniqueStorage()._payloadVariant = newValue}
    }
    
    var decoded: DataMessage {
        get {
            if case .decoded(let v)? = _storage._payloadVariant {return v}
            return DataMessage()
        }
        set {_uniqueStorage()._payloadVariant = .decoded(newValue)}
    }
    
    var encrypted: Data {
        get {
            if case .encrypted(let v)? = _storage._payloadVariant {return v}
            return Data()
        }
        set {_uniqueStorage()._payloadVariant = .encrypted(newValue)}
    }
    
    ///
    /// A unique ID for this packet.
    /// Always 0 for no-ack packets or non broadcast packets (and therefore take zero bytes of space).
    /// Otherwise a unique ID for this packet, useful for flooding algorithms.
    /// ID only needs to be unique on a _per sender_ basis, and it only
    /// needs to be unique for a few minutes (long enough to last for the length of
    /// any ACK or the completion of a mesh broadcast flood).
    /// Note: Our crypto implementation uses this id as well.
    /// See [crypto](/developers/device/encryption.md) for details.
    /// FIXME - really should be fixed32 instead, this encoding only
    /// hurts the ble link though.
    var id: UInt32 {
        get {return _storage._id}
        set {_uniqueStorage()._id = newValue}
    }
    
    ///
    /// The time this message was received by the esp32 (secs since 1970).
    /// Note: this field is _never_ sent on the radio link itself (to save space) Times
    /// are typically not sent over the mesh, but they will be added to any Packet
    /// (chain of SubPacket) sent to the phone (so the phone can know exact time of reception)
    var rxTime: UInt32 {
        get {return _storage._rxTime}
        set {_uniqueStorage()._rxTime = newValue}
    }
    
    ///
    /// *Never* sent over the radio links.
    /// Set during reception to indicate the SNR of this packet.
    /// Used to collect statistics on current link quality.
    var rxSnr: Float {
        get {return _storage._rxSnr}
        set {_uniqueStorage()._rxSnr = newValue}
    }
    
    ///
    /// If unset treated as zero (no forwarding, send to adjacent nodes only)
    /// if 1, allow hopping through one node, etc...
    /// For our usecase real world topologies probably have a max of about 3.
    /// This field is normally placed into a few of bits in the header.
    var hopLimit: UInt32 {
        get {return _storage._hopLimit}
        set {_uniqueStorage()._hopLimit = newValue}
    }
    
    ///
    /// This packet is being sent as a reliable message, we would prefer it to arrive at the destination.
    /// We would like to receive a ack packet in response.
    /// Broadcasts messages treat this flag specially: Since acks for broadcasts would
    /// rapidly flood the channel, the normal ack behavior is suppressed.
    /// Instead, the original sender listens to see if at least one node is rebroadcasting this packet (because naive flooding algorithm).
    /// If it hears that the odds (given typical LoRa topologies) the odds are very high that every node should eventually receive the message.
    /// So FloodingRouter.cpp generates an implicit ack which is delivered to the original sender.
    /// If after some time we don't hear anyone rebroadcast our packet, we will timeout and retransmit, using the regular resend logic.
    /// Note: This flag is normally sent in a flag bit in the header when sent over the wire
    var wantAck: Bool {
        get {return _storage._wantAck}
        set {_uniqueStorage()._wantAck = newValue}
    }
    
    ///
    /// The priority of this message for sending.
    /// See MeshPacket.Priority description for more details.
    var priority: MeshPacket.Priority {
        get {return _storage._priority}
        set {_uniqueStorage()._priority = newValue}
    }
    
    ///
    /// rssi of received packet. Only sent to phone for dispay purposes.
    var rxRssi: Int32 {
        get {return _storage._rxRssi}
        set {_uniqueStorage()._rxRssi = newValue}
    }
    
    ///
    /// Describe if this message is delayed
    var delayed: MeshPacket.Delayed {
        get {return _storage._delayed}
        set {_uniqueStorage()._delayed = newValue}
    }
    
    var unknownFields = SwiftProtobuf.UnknownStorage()
    
    enum OneOf_PayloadVariant: Equatable {
        case decoded(DataMessage)
        case encrypted(Data)
        
#if !swift(>=4.1)
        static func ==(lhs: MeshPacket.OneOf_PayloadVariant, rhs: MeshPacket.OneOf_PayloadVariant) -> Bool {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch (lhs, rhs) {
            case (.decoded, .decoded): return {
                guard case .decoded(let l) = lhs, case .decoded(let r) = rhs else { preconditionFailure() }
                return l == r
            }()
            case (.encrypted, .encrypted): return {
                guard case .encrypted(let l) = lhs, case .encrypted(let r) = rhs else { preconditionFailure() }
                return l == r
            }()
            default: return false
            }
        }
#endif
    }
    
    ///
    /// The priority of this message for sending.
    /// Higher priorities are sent first (when managing the transmit queue).
    /// This field is never sent over the air, it is only used internally inside of a local device node.
    /// API clients (either on the local node or connected directly to the node)
    /// can set this parameter if necessary.
    ///
    /// (values must be <= 127 to keep protobuf field to one byte in size.
    ///
    /// Detailed background on this field:
    ///
    /// I noticed a funny side effect of lora being so slow: Usually when making
    /// a protocol there isn’t much need to use message priority to change the order
    /// of transmission (because interfaces are fairly fast).
    /// But for lora where packets can take a few seconds each, it is very important
    /// to make sure that critical packets are sent ASAP.
    /// In the case of meshtastic that means we want to send protocol acks as soon as possible
    /// (to prevent unneeded retransmissions), we want routing messages to be sent next,
    /// then messages marked as reliable and finally ‘background’ packets like periodic position updates.
    ///
    /// So I bit the bullet and implemented a new (internal - not sent over the air)
    /// field in MeshPacket called ‘priority’.
    /// And the transmission queue in the router object is now a priority queue.
    enum Priority: SwiftProtobuf.Enum {
        typealias RawValue = Int
        
        ///
        /// Treated as Priority.DEFAULT
        case unset // = 0
        case min // = 1
        
        ///
        /// Background position updates are sent with very low priority -
        /// if the link is super congested they might not go out at all
        case background // = 10
        
        ///
        /// This priority is used for most messages that don't have a priority set
        case `default` // = 64
        
        ///
        /// If priority is unset but the message is marked as want_ack,
        /// assume it is important and use a slightly higher priority
        case reliable // = 70
        
        ///
        /// Ack/naks are sent with very high priority to ensure that retransmission
        /// stops as soon as possible
        case ack // = 120
        case max // = 127
        case UNRECOGNIZED(Int)
        
        init() {
            self = .unset
        }
        
        init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .unset
            case 1: self = .min
            case 10: self = .background
            case 64: self = .default
            case 70: self = .reliable
            case 120: self = .ack
            case 127: self = .max
            default: self = .UNRECOGNIZED(rawValue)
            }
        }
        
        var rawValue: Int {
            switch self {
            case .unset: return 0
            case .min: return 1
            case .background: return 10
            case .default: return 64
            case .reliable: return 70
            case .ack: return 120
            case .max: return 127
            case .UNRECOGNIZED(let i): return i
            }
        }
        
    }
    
    ///
    /// Identify if this is a delayed packet
    enum Delayed: SwiftProtobuf.Enum {
        typealias RawValue = Int
        
        ///
        /// If unset, the message is being sent in real time.
        case noDelay // = 0
        
        ///
        /// The message is delayed and was originally a broadcast
        case broadcast // = 1
        
        ///
        /// The message is delayed and was originally a direct message
        case direct // = 2
        case UNRECOGNIZED(Int)
        
        init() {
            self = .noDelay
        }
        
        init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .noDelay
            case 1: self = .broadcast
            case 2: self = .direct
            default: self = .UNRECOGNIZED(rawValue)
            }
        }
        
        var rawValue: Int {
            switch self {
            case .noDelay: return 0
            case .broadcast: return 1
            case .direct: return 2
            case .UNRECOGNIZED(let i): return i
            }
        }
        
    }
    
    init() {}
    
    fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension MeshPacket.Priority: CaseIterable {
    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static var allCases: [MeshPacket.Priority] = [
        .unset,
        .min,
        .background,
        .default,
        .reliable,
        .ack,
        .max,
    ]
}

extension MeshPacket.Delayed: CaseIterable {
    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static var allCases: [MeshPacket.Delayed] = [
        .noDelay,
        .broadcast,
        .direct,
    ]
}

#endif  // swift(>=4.2)

///
/// The bluetooth to device link:
///
/// Old BTLE protocol docs from TODO, merge in above and make real docs...
///
/// use protocol buffers, and NanoPB
///
/// messages from device to phone:
/// POSITION_UPDATE (..., time)
/// TEXT_RECEIVED(from, text, time)
/// OPAQUE_RECEIVED(from, payload, time) (for signal messages or other applications)
///
/// messages from phone to device:
/// SET_MYID(id, human readable long, human readable short) (send down the unique ID
/// string used for this node, a human readable string shown for that id, and a very
/// short human readable string suitable for oled screen) SEND_OPAQUE(dest, payload)
/// (for signal messages or other applications) SEND_TEXT(dest, text) Get all
/// nodes() (returns list of nodes, with full info, last time seen, loc, battery
/// level etc) SET_CONFIG (switches device to a new set of radio params and
/// preshared key, drops all existing nodes, force our node to rejoin this new group)
///
/// Full information about a node on the mesh
struct NodeInfo {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    ///
    /// The node number
    var num: UInt32 = 0
    
    ///
    /// The user info for this node
    var user: User {
        get {return _user ?? User()}
        set {_user = newValue}
    }
    /// Returns true if `user` has been explicitly set.
    var hasUser: Bool {return self._user != nil}
    /// Clears the value of `user`. Subsequent reads from it will return its default value.
    mutating func clearUser() {self._user = nil}
    
    ///
    /// This position data. Note: before 1.2.14 we would also store the last time we've heard from this node in position.time, that is no longer true.
    /// Position.time now indicates the last time we received a POSITION from that node.
    var position: Position {
        get {return _position ?? Position()}
        set {_position = newValue}
    }
    /// Returns true if `position` has been explicitly set.
    var hasPosition: Bool {return self._position != nil}
    /// Clears the value of `position`. Subsequent reads from it will return its default value.
    mutating func clearPosition() {self._position = nil}
    
    ///
    /// Returns the Signal-to-noise ratio (SNR) of the last received message,
    /// as measured by the receiver. Return SNR of the last received message in dB
    var snr: Float = 0
    
    ///
    /// Set to indicate the last time we received a packet from this node
    var lastHeard: UInt32 = 0
    
    var unknownFields = SwiftProtobuf.UnknownStorage()
    
    init() {}
    
    fileprivate var _user: User? = nil
    fileprivate var _position: Position? = nil
}

///
/// Unique local debugging info for this node
/// Note: we don't include position or the user info, because that will come in the
/// Sent to the phone in response to WantNodes.
struct MyNodeInfo {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    ///
    /// Tells the phone what our node number is, default starting value is
    /// lowbyte of macaddr, but it will be fixed if that is already in use
    var myNodeNum: UInt32 {
        get {return _storage._myNodeNum}
        set {_uniqueStorage()._myNodeNum = newValue}
    }
    
    ///
    /// Note: This flag merely means we detected a hardware GPS in our node.
    /// Not the same as UserPreferences.location_sharing
    var hasGps_p: Bool {
        get {return _storage._hasGps_p}
        set {_uniqueStorage()._hasGps_p = newValue}
    }
    
    ///
    /// # of frequencies that can be used (set at build time in the device flash image).
    /// Note: this is different from max_channels, this field is telling the # of frequency bands this node can use.
    /// (old name was num_channels)
    var numBands: UInt32 {
        get {return _storage._numBands}
        set {_uniqueStorage()._numBands = newValue}
    }
    
    ///
    /// The maximum number of 'software' channels that can be set on this node.
    var maxChannels: UInt32 {
        get {return _storage._maxChannels}
        set {_uniqueStorage()._maxChannels = newValue}
    }
    
    ///
    /// Deprecated! ONLY USED IN DEVICE CODE (for upgrading old 1.0 firmwares) DO NOT READ ELSEWHERE.
    /// The region code for my radio (US, CN, etc...)
    /// Note: This string is deprecated.
    /// The 1.0 builds populate it based on the flashed firmware name.
    /// But for newer builds this string will be unpopulated (missing/null).
    /// For those builds you should instead look at the new read/write region enum in UserSettings
    /// The format of this string was 1.0-US or 1.0-CN etc.. Or empty string if unset.
    var region: String {
        get {return _storage._region}
        set {_uniqueStorage()._region = newValue}
    }
    
    ///
    /// TBEAM, HELTEC, etc...
    /// Starting in 1.2.11 moved to hw_model enum in the NodeInfo object.
    /// Apps will still need the string here for older builds
    /// (so OTA update can find the right image), but if the enum is available it will be used instead.
    var hwModelDeprecated: String {
        get {return _storage._hwModelDeprecated}
        set {_uniqueStorage()._hwModelDeprecated = newValue}
    }
    
    ///
    /// 0.0.5 etc...
    var firmwareVersion: String {
        get {return _storage._firmwareVersion}
        set {_uniqueStorage()._firmwareVersion = newValue}
    }
    
    ///
    /// An error message we'd like to report back to the mothership through analytics.
    /// It indicates a serious bug occurred on the device, the device coped with it,
    /// but we still want to tell the devs about the bug.
    /// This field will be cleared after the phone reads MyNodeInfo
    /// (i.e. it will only be reported once)
    /// a numeric error code to go with error message, zero means no error
    var errorCode: CriticalErrorCode {
        get {return _storage._errorCode}
        set {_uniqueStorage()._errorCode = newValue}
    }
    
    ///
    /// A numeric error address (nonzero if available)
    var errorAddress: UInt32 {
        get {return _storage._errorAddress}
        set {_uniqueStorage()._errorAddress = newValue}
    }
    
    ///
    /// The total number of errors this node has ever encountered
    /// (well - since the last time we discarded preferences)
    var errorCount: UInt32 {
        get {return _storage._errorCount}
        set {_uniqueStorage()._errorCount = newValue}
    }
    
    ///
    /// The total number of reboots this node has ever encountered
    /// (well - since the last time we discarded preferences)
    var rebootCount: UInt32 {
        get {return _storage._rebootCount}
        set {_uniqueStorage()._rebootCount = newValue}
    }
    
    ///
    /// Calculated bitrate of the current channel (in Bytes Per Second)
    var bitrate: Float {
        get {return _storage._bitrate}
        set {_uniqueStorage()._bitrate = newValue}
    }
    
    ///
    /// How long before we consider a message abandoned and we can clear our
    /// caches of any messages in flight Normally quite large to handle the worst case
    /// message delivery time, 5 minutes.
    /// Formerly called FLOOD_EXPIRE_TIME in the device code
    var messageTimeoutMsec: UInt32 {
        get {return _storage._messageTimeoutMsec}
        set {_uniqueStorage()._messageTimeoutMsec = newValue}
    }
    
    ///
    /// The minimum app version that can talk to this device.
    /// Phone/PC apps should compare this to their build number and if too low tell the user they must update their app
    var minAppVersion: UInt32 {
        get {return _storage._minAppVersion}
        set {_uniqueStorage()._minAppVersion = newValue}
    }
    
    ///
    /// 24 time windows of 1hr each with the airtime transmitted out of the device per hour.
    var airPeriodTx: [UInt32] {
        get {return _storage._airPeriodTx}
        set {_uniqueStorage()._airPeriodTx = newValue}
    }
    
    ///
    /// 24 time windows of 1hr each with the airtime of valid packets for your mesh.
    var airPeriodRx: [UInt32] {
        get {return _storage._airPeriodRx}
        set {_uniqueStorage()._airPeriodRx = newValue}
    }
    
    ///
    /// Is the device wifi capable?
    var hasWifi_p: Bool {
        get {return _storage._hasWifi_p}
        set {_uniqueStorage()._hasWifi_p = newValue}
    }
    
    ///
    /// Utilization for the current channel, including well formed TX, RX and malformed RX (aka noise).
    var channelUtilization: Float {
        get {return _storage._channelUtilization}
        set {_uniqueStorage()._channelUtilization = newValue}
    }
    
    ///
    /// Percent of airtime for transmission used within the last hour.
    var airUtilTx: Float {
        get {return _storage._airUtilTx}
        set {_uniqueStorage()._airUtilTx = newValue}
    }
    
    var unknownFields = SwiftProtobuf.UnknownStorage()
    
    init() {}
    
    fileprivate var _storage = _StorageClass.defaultInstance
}

///
/// Debug output from the device.
///
/// To minimize the size of records inside the device code, if a time/source/level is not set
/// on the message it is assumed to be a continuation of the previously sent message.
/// This allows the device code to use fixed maxlen 64 byte strings for messages,
/// and then extend as needed by emitting multiple records.
struct LogRecord {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    var message: String = String()
    
    ///
    /// Seconds since 1970 - or 0 for unknown/unset
    var time: UInt32 = 0
    
    ///
    /// Usually based on thread name - if known
    var source: String = String()
    
    ///
    /// Not yet set
    var level: LogRecord.Level = .unset
    
    var unknownFields = SwiftProtobuf.UnknownStorage()
    
    ///
    /// Log levels, chosen to match python logging conventions.
    enum Level: SwiftProtobuf.Enum {
        typealias RawValue = Int
        case unset // = 0
        case critical // = 50
        case error // = 40
        case warning // = 30
        case info // = 20
        case debug // = 10
        case trace // = 5
        case UNRECOGNIZED(Int)
        
        init() {
            self = .unset
        }
        
        init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .unset
            case 5: self = .trace
            case 10: self = .debug
            case 20: self = .info
            case 30: self = .warning
            case 40: self = .error
            case 50: self = .critical
            default: self = .UNRECOGNIZED(rawValue)
            }
        }
        
        var rawValue: Int {
            switch self {
            case .unset: return 0
            case .trace: return 5
            case .debug: return 10
            case .info: return 20
            case .warning: return 30
            case .error: return 40
            case .critical: return 50
            case .UNRECOGNIZED(let i): return i
            }
        }
        
    }
    
    init() {}
}

#if swift(>=4.2)

extension LogRecord.Level: CaseIterable {
    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static var allCases: [LogRecord.Level] = [
        .unset,
        .critical,
        .error,
        .warning,
        .info,
        .debug,
        .trace,
    ]
}

#endif  // swift(>=4.2)

///
/// Packets from the radio to the phone will appear on the fromRadio characteristic.
/// It will support READ and NOTIFY. When a new packet arrives the device will BLE notify?
/// It will sit in that descriptor until consumed by the phone,
/// at which point the next item in the FIFO will be populated.
struct FromRadio {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    ///
    /// The packet num, used to allow the phone to request missing read packets from the FIFO,
    /// see our bluetooth docs
    var num: UInt32 = 0
    
    var payloadVariant: FromRadio.OneOf_PayloadVariant? = nil
    
    var packet: MeshPacket {
        get {
            if case .packet(let v)? = payloadVariant {return v}
            return MeshPacket()
        }
        set {payloadVariant = .packet(newValue)}
    }
    
    ///
    /// Tells the phone what our node number is, can be -1 if we've not yet joined a mesh.
    /// NOTE: This ID must not change - to keep (minimal) compatibility with <1.2 version of android apps.
    var myInfo: MyNodeInfo {
        get {
            if case .myInfo(let v)? = payloadVariant {return v}
            return MyNodeInfo()
        }
        set {payloadVariant = .myInfo(newValue)}
    }
    
    ///
    /// One packet is sent for each node in the on radio DB
    /// starts over with the first node in our DB
    var nodeInfo: NodeInfo {
        get {
            if case .nodeInfo(let v)? = payloadVariant {return v}
            return NodeInfo()
        }
        set {payloadVariant = .nodeInfo(newValue)}
    }
    
    ///
    /// Set to send debug console output over our protobuf stream
    var logRecord: LogRecord {
        get {
            if case .logRecord(let v)? = payloadVariant {return v}
            return LogRecord()
        }
        set {payloadVariant = .logRecord(newValue)}
    }
    
    ///
    /// Sent as true once the device has finished sending all of the responses to want_config
    /// recipient should check if this ID matches our original request nonce, if
    /// not, it means your config responses haven't started yet.
    /// NOTE: This ID must not change - to keep (minimal) compatibility with <1.2 version of android apps.
    var configCompleteID: UInt32 {
        get {
            if case .configCompleteID(let v)? = payloadVariant {return v}
            return 0
        }
        set {payloadVariant = .configCompleteID(newValue)}
    }
    
    ///
    /// Sent to tell clients the radio has just rebooted.
    /// Set to true if present.
    /// Not used on all transports, currently just used for the serial console.
    /// NOTE: This ID must not change - to keep (minimal) compatibility with <1.2 version of android apps.
    var rebooted: Bool {
        get {
            if case .rebooted(let v)? = payloadVariant {return v}
            return false
        }
        set {payloadVariant = .rebooted(newValue)}
    }
    
    var unknownFields = SwiftProtobuf.UnknownStorage()
    
    enum OneOf_PayloadVariant: Equatable {
        case packet(MeshPacket)
        ///
        /// Tells the phone what our node number is, can be -1 if we've not yet joined a mesh.
        /// NOTE: This ID must not change - to keep (minimal) compatibility with <1.2 version of android apps.
        case myInfo(MyNodeInfo)
        ///
        /// One packet is sent for each node in the on radio DB
        /// starts over with the first node in our DB
        case nodeInfo(NodeInfo)
        ///
        /// Set to send debug console output over our protobuf stream
        case logRecord(LogRecord)
        ///
        /// Sent as true once the device has finished sending all of the responses to want_config
        /// recipient should check if this ID matches our original request nonce, if
        /// not, it means your config responses haven't started yet.
        /// NOTE: This ID must not change - to keep (minimal) compatibility with <1.2 version of android apps.
        case configCompleteID(UInt32)
        ///
        /// Sent to tell clients the radio has just rebooted.
        /// Set to true if present.
        /// Not used on all transports, currently just used for the serial console.
        /// NOTE: This ID must not change - to keep (minimal) compatibility with <1.2 version of android apps.
        case rebooted(Bool)
        
#if !swift(>=4.1)
        static func ==(lhs: FromRadio.OneOf_PayloadVariant, rhs: FromRadio.OneOf_PayloadVariant) -> Bool {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch (lhs, rhs) {
            case (.packet, .packet): return {
                guard case .packet(let l) = lhs, case .packet(let r) = rhs else { preconditionFailure() }
                return l == r
            }()
            case (.myInfo, .myInfo): return {
                guard case .myInfo(let l) = lhs, case .myInfo(let r) = rhs else { preconditionFailure() }
                return l == r
            }()
            case (.nodeInfo, .nodeInfo): return {
                guard case .nodeInfo(let l) = lhs, case .nodeInfo(let r) = rhs else { preconditionFailure() }
                return l == r
            }()
            case (.logRecord, .logRecord): return {
                guard case .logRecord(let l) = lhs, case .logRecord(let r) = rhs else { preconditionFailure() }
                return l == r
            }()
            case (.configCompleteID, .configCompleteID): return {
                guard case .configCompleteID(let l) = lhs, case .configCompleteID(let r) = rhs else { preconditionFailure() }
                return l == r
            }()
            case (.rebooted, .rebooted): return {
                guard case .rebooted(let l) = lhs, case .rebooted(let r) = rhs else { preconditionFailure() }
                return l == r
            }()
            default: return false
            }
        }
#endif
    }
    
    init() {}
}

///
/// Packets/commands to the radio will be written (reliably) to the toRadio characteristic.
/// Once the write completes the phone can assume it is handled.
struct ToRadio {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    var payloadVariant: ToRadio.OneOf_PayloadVariant? = nil
    
    ///
    /// Send this packet on the mesh
    var packet: MeshPacket {
        get {
            if case .packet(let v)? = payloadVariant {return v}
            return MeshPacket()
        }
        set {payloadVariant = .packet(newValue)}
    }
    
    ///
    /// Information about the peer, sent after the phone sneds want_config_id.
    /// Old clients do not send this, which is fine.
    var peerInfo: ToRadio.PeerInfo {
        get {
            if case .peerInfo(let v)? = payloadVariant {return v}
            return ToRadio.PeerInfo()
        }
        set {payloadVariant = .peerInfo(newValue)}
    }
    
    ///
    /// Phone wants radio to send full node db to the phone, This is
    /// typically the first packet sent to the radio when the phone gets a
    /// bluetooth connection. The radio will respond by sending back a
    /// MyNodeInfo, a owner, a radio config and a series of
    /// FromRadio.node_infos, and config_complete
    /// the integer you write into this field will be reported back in the
    /// config_complete_id response this allows clients to never be confused by
    /// a stale old partially sent config.
    var wantConfigID: UInt32 {
        get {
            if case .wantConfigID(let v)? = payloadVariant {return v}
            return 0
        }
        set {payloadVariant = .wantConfigID(newValue)}
    }
    
    ///
    /// Tell API server we are disconnecting now.
    /// This is useful for serial links where there is no hardware/protocol based notification that the client has dropped the link.
    /// (Sending this message is optional for clients)
    var disconnect: Bool {
        get {
            if case .disconnect(let v)? = payloadVariant {return v}
            return false
        }
        set {payloadVariant = .disconnect(newValue)}
    }
    
    var unknownFields = SwiftProtobuf.UnknownStorage()
    
    enum OneOf_PayloadVariant: Equatable {
        ///
        /// Send this packet on the mesh
        case packet(MeshPacket)
        ///
        /// Information about the peer, sent after the phone sneds want_config_id.
        /// Old clients do not send this, which is fine.
        case peerInfo(ToRadio.PeerInfo)
        ///
        /// Phone wants radio to send full node db to the phone, This is
        /// typically the first packet sent to the radio when the phone gets a
        /// bluetooth connection. The radio will respond by sending back a
        /// MyNodeInfo, a owner, a radio config and a series of
        /// FromRadio.node_infos, and config_complete
        /// the integer you write into this field will be reported back in the
        /// config_complete_id response this allows clients to never be confused by
        /// a stale old partially sent config.
        case wantConfigID(UInt32)
        ///
        /// Tell API server we are disconnecting now.
        /// This is useful for serial links where there is no hardware/protocol based notification that the client has dropped the link.
        /// (Sending this message is optional for clients)
        case disconnect(Bool)
        
#if !swift(>=4.1)
        static func ==(lhs: ToRadio.OneOf_PayloadVariant, rhs: ToRadio.OneOf_PayloadVariant) -> Bool {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch (lhs, rhs) {
            case (.packet, .packet): return {
                guard case .packet(let l) = lhs, case .packet(let r) = rhs else { preconditionFailure() }
                return l == r
            }()
            case (.peerInfo, .peerInfo): return {
                guard case .peerInfo(let l) = lhs, case .peerInfo(let r) = rhs else { preconditionFailure() }
                return l == r
            }()
            case (.wantConfigID, .wantConfigID): return {
                guard case .wantConfigID(let l) = lhs, case .wantConfigID(let r) = rhs else { preconditionFailure() }
                return l == r
            }()
            case (.disconnect, .disconnect): return {
                guard case .disconnect(let l) = lhs, case .disconnect(let r) = rhs else { preconditionFailure() }
                return l == r
            }()
            default: return false
            }
        }
#endif
    }
    
    ///
    /// Instead of sending want_config_id as a uint32, newer clients send this structure with information about the client.
    struct PeerInfo {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.
        
        ///
        /// The numeric version code for the client application, which in some cases are used to control device behavior (so the device can
        /// make assumptions about who is using the API.
        var appVersion: UInt32 = 0
        
        ///
        /// True if the peer device can gateway MQTT packets.
        /// If true, the device will not try to send packets to the internet directly,
        /// instead it will pass the packets to the peer for dispatching.
        /// This feature is optional, if set to false the device will assume the client can not gateway to MQTT.
        var mqttGateway: Bool = false
        
        var unknownFields = SwiftProtobuf.UnknownStorage()
        
        init() {}
    }
    
    init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension HardwareModel: @unchecked Sendable {}
extension Team: @unchecked Sendable {}
extension Constants: @unchecked Sendable {}
extension CriticalErrorCode: @unchecked Sendable {}
extension Position: @unchecked Sendable {}
extension Position.LocSource: @unchecked Sendable {}
extension Position.AltSource: @unchecked Sendable {}
extension User: @unchecked Sendable {}
extension RouteDiscovery: @unchecked Sendable {}
extension Routing: @unchecked Sendable {}
extension Routing.OneOf_Variant: @unchecked Sendable {}
extension Routing.Error: @unchecked Sendable {}
extension DataMessage: @unchecked Sendable {}
extension MeshPacket: @unchecked Sendable {}
extension MeshPacket.OneOf_PayloadVariant: @unchecked Sendable {}
extension MeshPacket.Priority: @unchecked Sendable {}
extension MeshPacket.Delayed: @unchecked Sendable {}
extension NodeInfo: @unchecked Sendable {}
extension MyNodeInfo: @unchecked Sendable {}
extension LogRecord: @unchecked Sendable {}
extension LogRecord.Level: @unchecked Sendable {}
extension FromRadio: @unchecked Sendable {}
extension FromRadio.OneOf_PayloadVariant: @unchecked Sendable {}
extension ToRadio: @unchecked Sendable {}
extension ToRadio.OneOf_PayloadVariant: @unchecked Sendable {}
extension ToRadio.PeerInfo: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension HardwareModel: SwiftProtobuf._ProtoNameProviding {
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "UNSET"),
        1: .same(proto: "TLORA_V2"),
        2: .same(proto: "TLORA_V1"),
        3: .same(proto: "TLORA_V2_1_1p6"),
        4: .same(proto: "TBEAM"),
        5: .same(proto: "HELTEC_V2_0"),
        6: .same(proto: "TBEAM0p7"),
        7: .same(proto: "T_ECHO"),
        8: .same(proto: "TLORA_V1_1p3"),
        9: .same(proto: "RAK4631"),
        10: .same(proto: "HELTEC_V2_1"),
        11: .same(proto: "HELTEC_V1"),
        32: .same(proto: "LORA_RELAY_V1"),
        33: .same(proto: "NRF52840DK"),
        34: .same(proto: "PPR"),
        35: .same(proto: "GENIEBLOCKS"),
        36: .same(proto: "NRF52_UNKNOWN"),
        37: .same(proto: "PORTDUINO"),
        38: .same(proto: "ANDROID_SIM"),
        39: .same(proto: "DIY_V1"),
        40: .same(proto: "RAK11200"),
        41: .same(proto: "NANO_G1"),
        43: .same(proto: "DR_DEV"),
        255: .same(proto: "PRIVATE_HW"),
    ]
}

extension Team: SwiftProtobuf._ProtoNameProviding {
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "CLEAR"),
        1: .same(proto: "CYAN"),
        2: .same(proto: "WHITE"),
        3: .same(proto: "YELLOW"),
        4: .same(proto: "ORANGE"),
        5: .same(proto: "MAGENTA"),
        6: .same(proto: "RED"),
        7: .same(proto: "MAROON"),
        8: .same(proto: "PURPLE"),
        9: .same(proto: "DARK_BLUE"),
        10: .same(proto: "BLUE"),
        11: .same(proto: "TEAL"),
        12: .same(proto: "GREEN"),
        13: .same(proto: "DARK_GREEN"),
        14: .same(proto: "BROWN"),
    ]
}

extension Constants: SwiftProtobuf._ProtoNameProviding {
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "Unused"),
        237: .same(proto: "DATA_PAYLOAD_LEN"),
    ]
}

extension CriticalErrorCode: SwiftProtobuf._ProtoNameProviding {
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "None"),
        1: .same(proto: "TxWatchdog"),
        2: .same(proto: "SleepEnterWait"),
        3: .same(proto: "NoRadio"),
        4: .same(proto: "Unspecified"),
        5: .same(proto: "UBloxInitFailed"),
        6: .same(proto: "NoAXP192"),
        7: .same(proto: "InvalidRadioSetting"),
        8: .same(proto: "TransmitFailed"),
        9: .same(proto: "Brownout"),
        10: .same(proto: "SX1262Failure"),
        11: .same(proto: "RadioSpiBug"),
    ]
}

extension Position: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = "Position"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "latitude_i"),
        2: .standard(proto: "longitude_i"),
        3: .same(proto: "altitude"),
        4: .standard(proto: "battery_level"),
        9: .same(proto: "time"),
        10: .standard(proto: "location_source"),
        11: .standard(proto: "altitude_source"),
        12: .standard(proto: "pos_timestamp"),
        13: .standard(proto: "pos_time_millis"),
        14: .standard(proto: "altitude_hae"),
        15: .standard(proto: "alt_geoid_sep"),
        16: .same(proto: "PDOP"),
        17: .same(proto: "HDOP"),
        18: .same(proto: "VDOP"),
        19: .standard(proto: "gps_accuracy"),
        20: .standard(proto: "ground_speed"),
        21: .standard(proto: "ground_track"),
        22: .standard(proto: "fix_quality"),
        23: .standard(proto: "fix_type"),
        24: .standard(proto: "sats_in_view"),
        25: .standard(proto: "sensor_id"),
        40: .standard(proto: "pos_next_update"),
        41: .standard(proto: "pos_seq_number"),
    ]
    
    fileprivate class _StorageClass {
        var _latitudeI: Int32 = 0
        var _longitudeI: Int32 = 0
        var _altitude: Int32 = 0
        var _batteryLevel: Int32 = 0
        var _time: UInt32 = 0
        var _locationSource: Position.LocSource = .locsrcUnspecified
        var _altitudeSource: Position.AltSource = .altsrcUnspecified
        var _posTimestamp: UInt32 = 0
        var _posTimeMillis: Int32 = 0
        var _altitudeHae: Int32 = 0
        var _altGeoidSep: Int32 = 0
        var _pdop: UInt32 = 0
        var _hdop: UInt32 = 0
        var _vdop: UInt32 = 0
        var _gpsAccuracy: UInt32 = 0
        var _groundSpeed: UInt32 = 0
        var _groundTrack: UInt32 = 0
        var _fixQuality: UInt32 = 0
        var _fixType: UInt32 = 0
        var _satsInView: UInt32 = 0
        var _sensorID: UInt32 = 0
        var _posNextUpdate: UInt32 = 0
        var _posSeqNumber: UInt32 = 0
        
        static let defaultInstance = _StorageClass()
        
        private init() {}
        
        init(copying source: _StorageClass) {
            _latitudeI = source._latitudeI
            _longitudeI = source._longitudeI
            _altitude = source._altitude
            _batteryLevel = source._batteryLevel
            _time = source._time
            _locationSource = source._locationSource
            _altitudeSource = source._altitudeSource
            _posTimestamp = source._posTimestamp
            _posTimeMillis = source._posTimeMillis
            _altitudeHae = source._altitudeHae
            _altGeoidSep = source._altGeoidSep
            _pdop = source._pdop
            _hdop = source._hdop
            _vdop = source._vdop
            _gpsAccuracy = source._gpsAccuracy
            _groundSpeed = source._groundSpeed
            _groundTrack = source._groundTrack
            _fixQuality = source._fixQuality
            _fixType = source._fixType
            _satsInView = source._satsInView
            _sensorID = source._sensorID
            _posNextUpdate = source._posNextUpdate
            _posSeqNumber = source._posSeqNumber
        }
    }
    
    fileprivate mutating func _uniqueStorage() -> _StorageClass {
        if !isKnownUniquelyReferenced(&_storage) {
            _storage = _StorageClass(copying: _storage)
        }
        return _storage
    }
    
    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        _ = _uniqueStorage()
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            while let fieldNumber = try decoder.nextFieldNumber() {
                // The use of inline closures is to circumvent an issue where the compiler
                // allocates stack space for every case branch when no optimizations are
                // enabled. https://github.com/apple/swift-protobuf/issues/1034
                switch fieldNumber {
                case 1: try { try decoder.decodeSingularSFixed32Field(value: &_storage._latitudeI) }()
                case 2: try { try decoder.decodeSingularSFixed32Field(value: &_storage._longitudeI) }()
                case 3: try { try decoder.decodeSingularInt32Field(value: &_storage._altitude) }()
                case 4: try { try decoder.decodeSingularInt32Field(value: &_storage._batteryLevel) }()
                case 9: try { try decoder.decodeSingularFixed32Field(value: &_storage._time) }()
                case 10: try { try decoder.decodeSingularEnumField(value: &_storage._locationSource) }()
                case 11: try { try decoder.decodeSingularEnumField(value: &_storage._altitudeSource) }()
                case 12: try { try decoder.decodeSingularFixed32Field(value: &_storage._posTimestamp) }()
                case 13: try { try decoder.decodeSingularInt32Field(value: &_storage._posTimeMillis) }()
                case 14: try { try decoder.decodeSingularSInt32Field(value: &_storage._altitudeHae) }()
                case 15: try { try decoder.decodeSingularSInt32Field(value: &_storage._altGeoidSep) }()
                case 16: try { try decoder.decodeSingularUInt32Field(value: &_storage._pdop) }()
                case 17: try { try decoder.decodeSingularUInt32Field(value: &_storage._hdop) }()
                case 18: try { try decoder.decodeSingularUInt32Field(value: &_storage._vdop) }()
                case 19: try { try decoder.decodeSingularUInt32Field(value: &_storage._gpsAccuracy) }()
                case 20: try { try decoder.decodeSingularUInt32Field(value: &_storage._groundSpeed) }()
                case 21: try { try decoder.decodeSingularUInt32Field(value: &_storage._groundTrack) }()
                case 22: try { try decoder.decodeSingularUInt32Field(value: &_storage._fixQuality) }()
                case 23: try { try decoder.decodeSingularUInt32Field(value: &_storage._fixType) }()
                case 24: try { try decoder.decodeSingularUInt32Field(value: &_storage._satsInView) }()
                case 25: try { try decoder.decodeSingularUInt32Field(value: &_storage._sensorID) }()
                case 40: try { try decoder.decodeSingularUInt32Field(value: &_storage._posNextUpdate) }()
                case 41: try { try decoder.decodeSingularUInt32Field(value: &_storage._posSeqNumber) }()
                default: break
                }
            }
        }
    }
    
    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            if _storage._latitudeI != 0 {
                try visitor.visitSingularSFixed32Field(value: _storage._latitudeI, fieldNumber: 1)
            }
            if _storage._longitudeI != 0 {
                try visitor.visitSingularSFixed32Field(value: _storage._longitudeI, fieldNumber: 2)
            }
            if _storage._altitude != 0 {
                try visitor.visitSingularInt32Field(value: _storage._altitude, fieldNumber: 3)
            }
            if _storage._batteryLevel != 0 {
                try visitor.visitSingularInt32Field(value: _storage._batteryLevel, fieldNumber: 4)
            }
            if _storage._time != 0 {
                try visitor.visitSingularFixed32Field(value: _storage._time, fieldNumber: 9)
            }
            if _storage._locationSource != .locsrcUnspecified {
                try visitor.visitSingularEnumField(value: _storage._locationSource, fieldNumber: 10)
            }
            if _storage._altitudeSource != .altsrcUnspecified {
                try visitor.visitSingularEnumField(value: _storage._altitudeSource, fieldNumber: 11)
            }
            if _storage._posTimestamp != 0 {
                try visitor.visitSingularFixed32Field(value: _storage._posTimestamp, fieldNumber: 12)
            }
            if _storage._posTimeMillis != 0 {
                try visitor.visitSingularInt32Field(value: _storage._posTimeMillis, fieldNumber: 13)
            }
            if _storage._altitudeHae != 0 {
                try visitor.visitSingularSInt32Field(value: _storage._altitudeHae, fieldNumber: 14)
            }
            if _storage._altGeoidSep != 0 {
                try visitor.visitSingularSInt32Field(value: _storage._altGeoidSep, fieldNumber: 15)
            }
            if _storage._pdop != 0 {
                try visitor.visitSingularUInt32Field(value: _storage._pdop, fieldNumber: 16)
            }
            if _storage._hdop != 0 {
                try visitor.visitSingularUInt32Field(value: _storage._hdop, fieldNumber: 17)
            }
            if _storage._vdop != 0 {
                try visitor.visitSingularUInt32Field(value: _storage._vdop, fieldNumber: 18)
            }
            if _storage._gpsAccuracy != 0 {
                try visitor.visitSingularUInt32Field(value: _storage._gpsAccuracy, fieldNumber: 19)
            }
            if _storage._groundSpeed != 0 {
                try visitor.visitSingularUInt32Field(value: _storage._groundSpeed, fieldNumber: 20)
            }
            if _storage._groundTrack != 0 {
                try visitor.visitSingularUInt32Field(value: _storage._groundTrack, fieldNumber: 21)
            }
            if _storage._fixQuality != 0 {
                try visitor.visitSingularUInt32Field(value: _storage._fixQuality, fieldNumber: 22)
            }
            if _storage._fixType != 0 {
                try visitor.visitSingularUInt32Field(value: _storage._fixType, fieldNumber: 23)
            }
            if _storage._satsInView != 0 {
                try visitor.visitSingularUInt32Field(value: _storage._satsInView, fieldNumber: 24)
            }
            if _storage._sensorID != 0 {
                try visitor.visitSingularUInt32Field(value: _storage._sensorID, fieldNumber: 25)
            }
            if _storage._posNextUpdate != 0 {
                try visitor.visitSingularUInt32Field(value: _storage._posNextUpdate, fieldNumber: 40)
            }
            if _storage._posSeqNumber != 0 {
                try visitor.visitSingularUInt32Field(value: _storage._posSeqNumber, fieldNumber: 41)
            }
        }
        try unknownFields.traverse(visitor: &visitor)
    }
    
    static func ==(lhs: Position, rhs: Position) -> Bool {
        if lhs._storage !== rhs._storage {
            let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
                let _storage = _args.0
                let rhs_storage = _args.1
                if _storage._latitudeI != rhs_storage._latitudeI {return false}
                if _storage._longitudeI != rhs_storage._longitudeI {return false}
                if _storage._altitude != rhs_storage._altitude {return false}
                if _storage._batteryLevel != rhs_storage._batteryLevel {return false}
                if _storage._time != rhs_storage._time {return false}
                if _storage._locationSource != rhs_storage._locationSource {return false}
                if _storage._altitudeSource != rhs_storage._altitudeSource {return false}
                if _storage._posTimestamp != rhs_storage._posTimestamp {return false}
                if _storage._posTimeMillis != rhs_storage._posTimeMillis {return false}
                if _storage._altitudeHae != rhs_storage._altitudeHae {return false}
                if _storage._altGeoidSep != rhs_storage._altGeoidSep {return false}
                if _storage._pdop != rhs_storage._pdop {return false}
                if _storage._hdop != rhs_storage._hdop {return false}
                if _storage._vdop != rhs_storage._vdop {return false}
                if _storage._gpsAccuracy != rhs_storage._gpsAccuracy {return false}
                if _storage._groundSpeed != rhs_storage._groundSpeed {return false}
                if _storage._groundTrack != rhs_storage._groundTrack {return false}
                if _storage._fixQuality != rhs_storage._fixQuality {return false}
                if _storage._fixType != rhs_storage._fixType {return false}
                if _storage._satsInView != rhs_storage._satsInView {return false}
                if _storage._sensorID != rhs_storage._sensorID {return false}
                if _storage._posNextUpdate != rhs_storage._posNextUpdate {return false}
                if _storage._posSeqNumber != rhs_storage._posSeqNumber {return false}
                return true
            }
            if !storagesAreEqual {return false}
        }
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Position.LocSource: SwiftProtobuf._ProtoNameProviding {
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "LOCSRC_UNSPECIFIED"),
        1: .same(proto: "LOCSRC_MANUAL_ENTRY"),
        2: .same(proto: "LOCSRC_GPS_INTERNAL"),
        3: .same(proto: "LOCSRC_GPS_EXTERNAL"),
    ]
}

extension Position.AltSource: SwiftProtobuf._ProtoNameProviding {
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "ALTSRC_UNSPECIFIED"),
        1: .same(proto: "ALTSRC_MANUAL_ENTRY"),
        2: .same(proto: "ALTSRC_GPS_INTERNAL"),
        3: .same(proto: "ALTSRC_GPS_EXTERNAL"),
        4: .same(proto: "ALTSRC_BAROMETRIC"),
    ]
}

extension User: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = "User"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "id"),
        2: .standard(proto: "long_name"),
        3: .standard(proto: "short_name"),
        4: .same(proto: "macaddr"),
        6: .standard(proto: "hw_model"),
        7: .standard(proto: "is_licensed"),
        8: .same(proto: "team"),
        10: .standard(proto: "tx_power_dbm"),
        11: .standard(proto: "ant_gain_dbi"),
        12: .standard(proto: "ant_azimuth"),
    ]
    
    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
            case 2: try { try decoder.decodeSingularStringField(value: &self.longName) }()
            case 3: try { try decoder.decodeSingularStringField(value: &self.shortName) }()
            case 4: try { try decoder.decodeSingularBytesField(value: &self.macaddr) }()
            case 6: try { try decoder.decodeSingularEnumField(value: &self.hwModel) }()
            case 7: try { try decoder.decodeSingularBoolField(value: &self.isLicensed) }()
            case 8: try { try decoder.decodeSingularEnumField(value: &self.team) }()
            case 10: try { try decoder.decodeSingularUInt32Field(value: &self.txPowerDbm) }()
            case 11: try { try decoder.decodeSingularUInt32Field(value: &self.antGainDbi) }()
            case 12: try { try decoder.decodeSingularUInt32Field(value: &self.antAzimuth) }()
            default: break
            }
        }
    }
    
    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !self.id.isEmpty {
            try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
        }
        if !self.longName.isEmpty {
            try visitor.visitSingularStringField(value: self.longName, fieldNumber: 2)
        }
        if !self.shortName.isEmpty {
            try visitor.visitSingularStringField(value: self.shortName, fieldNumber: 3)
        }
        if !self.macaddr.isEmpty {
            try visitor.visitSingularBytesField(value: self.macaddr, fieldNumber: 4)
        }
        if self.hwModel != .unset {
            try visitor.visitSingularEnumField(value: self.hwModel, fieldNumber: 6)
        }
        if self.isLicensed != false {
            try visitor.visitSingularBoolField(value: self.isLicensed, fieldNumber: 7)
        }
        if self.team != .clear {
            try visitor.visitSingularEnumField(value: self.team, fieldNumber: 8)
        }
        if self.txPowerDbm != 0 {
            try visitor.visitSingularUInt32Field(value: self.txPowerDbm, fieldNumber: 10)
        }
        if self.antGainDbi != 0 {
            try visitor.visitSingularUInt32Field(value: self.antGainDbi, fieldNumber: 11)
        }
        if self.antAzimuth != 0 {
            try visitor.visitSingularUInt32Field(value: self.antAzimuth, fieldNumber: 12)
        }
        try unknownFields.traverse(visitor: &visitor)
    }
    
    static func ==(lhs: User, rhs: User) -> Bool {
        if lhs.id != rhs.id {return false}
        if lhs.longName != rhs.longName {return false}
        if lhs.shortName != rhs.shortName {return false}
        if lhs.macaddr != rhs.macaddr {return false}
        if lhs.hwModel != rhs.hwModel {return false}
        if lhs.isLicensed != rhs.isLicensed {return false}
        if lhs.team != rhs.team {return false}
        if lhs.txPowerDbm != rhs.txPowerDbm {return false}
        if lhs.antGainDbi != rhs.antGainDbi {return false}
        if lhs.antAzimuth != rhs.antAzimuth {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension RouteDiscovery: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = "RouteDiscovery"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        2: .same(proto: "route"),
    ]
    
    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 2: try { try decoder.decodeRepeatedFixed32Field(value: &self.route) }()
            default: break
            }
        }
    }
    
    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !self.route.isEmpty {
            try visitor.visitPackedFixed32Field(value: self.route, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }
    
    static func ==(lhs: RouteDiscovery, rhs: RouteDiscovery) -> Bool {
        if lhs.route != rhs.route {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Routing: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = "Routing"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "route_request"),
        2: .standard(proto: "route_reply"),
        3: .standard(proto: "error_reason"),
    ]
    
    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try {
                var v: RouteDiscovery?
                var hadOneofValue = false
                if let current = self.variant {
                    hadOneofValue = true
                    if case .routeRequest(let m) = current {v = m}
                }
                try decoder.decodeSingularMessageField(value: &v)
                if let v = v {
                    if hadOneofValue {try decoder.handleConflictingOneOf()}
                    self.variant = .routeRequest(v)
                }
            }()
            case 2: try {
                var v: RouteDiscovery?
                var hadOneofValue = false
                if let current = self.variant {
                    hadOneofValue = true
                    if case .routeReply(let m) = current {v = m}
                }
                try decoder.decodeSingularMessageField(value: &v)
                if let v = v {
                    if hadOneofValue {try decoder.handleConflictingOneOf()}
                    self.variant = .routeReply(v)
                }
            }()
            case 3: try {
                var v: Routing.Error?
                try decoder.decodeSingularEnumField(value: &v)
                if let v = v {
                    if self.variant != nil {try decoder.handleConflictingOneOf()}
                    self.variant = .errorReason(v)
                }
            }()
            default: break
            }
        }
    }
    
    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        switch self.variant {
        case .routeRequest?: try {
            guard case .routeRequest(let v)? = self.variant else { preconditionFailure() }
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }()
        case .routeReply?: try {
            guard case .routeReply(let v)? = self.variant else { preconditionFailure() }
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        }()
        case .errorReason?: try {
            guard case .errorReason(let v)? = self.variant else { preconditionFailure() }
            try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
        }()
        case nil: break
        }
        try unknownFields.traverse(visitor: &visitor)
    }
    
    static func ==(lhs: Routing, rhs: Routing) -> Bool {
        if lhs.variant != rhs.variant {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Routing.Error: SwiftProtobuf._ProtoNameProviding {
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "NONE"),
        1: .same(proto: "NO_ROUTE"),
        2: .same(proto: "GOT_NAK"),
        3: .same(proto: "TIMEOUT"),
        4: .same(proto: "NO_INTERFACE"),
        5: .same(proto: "MAX_RETRANSMIT"),
        6: .same(proto: "NO_CHANNEL"),
        7: .same(proto: "TOO_LARGE"),
        8: .same(proto: "NO_RESPONSE"),
        32: .same(proto: "BAD_REQUEST"),
        33: .same(proto: "NOT_AUTHORIZED"),
    ]
}

extension DataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = "Data"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "portnum"),
        2: .same(proto: "payload"),
        3: .standard(proto: "want_response"),
        4: .same(proto: "dest"),
        5: .same(proto: "source"),
        6: .standard(proto: "request_id"),
        7: .standard(proto: "reply_id"),
        8: .standard(proto: "is_tapback"),
    ]
    
    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularEnumField(value: &self.portnum) }()
            case 2: try { try decoder.decodeSingularBytesField(value: &self.payload) }()
            case 3: try { try decoder.decodeSingularBoolField(value: &self.wantResponse) }()
            case 4: try { try decoder.decodeSingularFixed32Field(value: &self.dest) }()
            case 5: try { try decoder.decodeSingularFixed32Field(value: &self.source) }()
            case 6: try { try decoder.decodeSingularFixed32Field(value: &self.requestID) }()
            case 7: try { try decoder.decodeSingularFixed32Field(value: &self.replyID) }()
            case 8: try { try decoder.decodeSingularBoolField(value: &self.isTapback) }()
            default: break
            }
        }
    }
    
    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if self.portnum != .unknownApp {
            try visitor.visitSingularEnumField(value: self.portnum, fieldNumber: 1)
        }
        if !self.payload.isEmpty {
            try visitor.visitSingularBytesField(value: self.payload, fieldNumber: 2)
        }
        if self.wantResponse != false {
            try visitor.visitSingularBoolField(value: self.wantResponse, fieldNumber: 3)
        }
        if self.dest != 0 {
            try visitor.visitSingularFixed32Field(value: self.dest, fieldNumber: 4)
        }
        if self.source != 0 {
            try visitor.visitSingularFixed32Field(value: self.source, fieldNumber: 5)
        }
        if self.requestID != 0 {
            try visitor.visitSingularFixed32Field(value: self.requestID, fieldNumber: 6)
        }
        if self.replyID != 0 {
            try visitor.visitSingularFixed32Field(value: self.replyID, fieldNumber: 7)
        }
        if self.isTapback != false {
            try visitor.visitSingularBoolField(value: self.isTapback, fieldNumber: 8)
        }
        try unknownFields.traverse(visitor: &visitor)
    }
    
    static func ==(lhs: DataMessage, rhs: DataMessage) -> Bool {
        if lhs.portnum != rhs.portnum {return false}
        if lhs.payload != rhs.payload {return false}
        if lhs.wantResponse != rhs.wantResponse {return false}
        if lhs.dest != rhs.dest {return false}
        if lhs.source != rhs.source {return false}
        if lhs.requestID != rhs.requestID {return false}
        if lhs.replyID != rhs.replyID {return false}
        if lhs.isTapback != rhs.isTapback {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension MeshPacket: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = "MeshPacket"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "from"),
        2: .same(proto: "to"),
        3: .same(proto: "channel"),
        4: .same(proto: "decoded"),
        5: .same(proto: "encrypted"),
        6: .same(proto: "id"),
        7: .standard(proto: "rx_time"),
        8: .standard(proto: "rx_snr"),
        10: .standard(proto: "hop_limit"),
        11: .standard(proto: "want_ack"),
        12: .same(proto: "priority"),
        13: .standard(proto: "rx_rssi"),
        15: .same(proto: "delayed"),
    ]
    
    fileprivate class _StorageClass {
        var _from: UInt32 = 0
        var _to: UInt32 = 0
        var _channel: UInt32 = 0
        var _payloadVariant: MeshPacket.OneOf_PayloadVariant?
        var _id: UInt32 = 0
        var _rxTime: UInt32 = 0
        var _rxSnr: Float = 0
        var _hopLimit: UInt32 = 0
        var _wantAck: Bool = false
        var _priority: MeshPacket.Priority = .unset
        var _rxRssi: Int32 = 0
        var _delayed: MeshPacket.Delayed = .noDelay
        
        static let defaultInstance = _StorageClass()
        
        private init() {}
        
        init(copying source: _StorageClass) {
            _from = source._from
            _to = source._to
            _channel = source._channel
            _payloadVariant = source._payloadVariant
            _id = source._id
            _rxTime = source._rxTime
            _rxSnr = source._rxSnr
            _hopLimit = source._hopLimit
            _wantAck = source._wantAck
            _priority = source._priority
            _rxRssi = source._rxRssi
            _delayed = source._delayed
        }
    }
    
    fileprivate mutating func _uniqueStorage() -> _StorageClass {
        if !isKnownUniquelyReferenced(&_storage) {
            _storage = _StorageClass(copying: _storage)
        }
        return _storage
    }
    
    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        _ = _uniqueStorage()
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            while let fieldNumber = try decoder.nextFieldNumber() {
                // The use of inline closures is to circumvent an issue where the compiler
                // allocates stack space for every case branch when no optimizations are
                // enabled. https://github.com/apple/swift-protobuf/issues/1034
                switch fieldNumber {
                case 1: try { try decoder.decodeSingularFixed32Field(value: &_storage._from) }()
                case 2: try { try decoder.decodeSingularFixed32Field(value: &_storage._to) }()
                case 3: try { try decoder.decodeSingularUInt32Field(value: &_storage._channel) }()
                case 4: try {
                    var v: DataMessage?
                    var hadOneofValue = false
                    if let current = _storage._payloadVariant {
                        hadOneofValue = true
                        if case .decoded(let m) = current {v = m}
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue {try decoder.handleConflictingOneOf()}
                        _storage._payloadVariant = .decoded(v)
                    }
                }()
                case 5: try {
                    var v: Data?
                    try decoder.decodeSingularBytesField(value: &v)
                    if let v = v {
                        if _storage._payloadVariant != nil {try decoder.handleConflictingOneOf()}
                        _storage._payloadVariant = .encrypted(v)
                    }
                }()
                case 6: try { try decoder.decodeSingularFixed32Field(value: &_storage._id) }()
                case 7: try { try decoder.decodeSingularFixed32Field(value: &_storage._rxTime) }()
                case 8: try { try decoder.decodeSingularFloatField(value: &_storage._rxSnr) }()
                case 10: try { try decoder.decodeSingularUInt32Field(value: &_storage._hopLimit) }()
                case 11: try { try decoder.decodeSingularBoolField(value: &_storage._wantAck) }()
                case 12: try { try decoder.decodeSingularEnumField(value: &_storage._priority) }()
                case 13: try { try decoder.decodeSingularInt32Field(value: &_storage._rxRssi) }()
                case 15: try { try decoder.decodeSingularEnumField(value: &_storage._delayed) }()
                default: break
                }
            }
        }
    }
    
    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every if/case branch local when no optimizations
            // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
            // https://github.com/apple/swift-protobuf/issues/1182
            if _storage._from != 0 {
                try visitor.visitSingularFixed32Field(value: _storage._from, fieldNumber: 1)
            }
            if _storage._to != 0 {
                try visitor.visitSingularFixed32Field(value: _storage._to, fieldNumber: 2)
            }
            if _storage._channel != 0 {
                try visitor.visitSingularUInt32Field(value: _storage._channel, fieldNumber: 3)
            }
            switch _storage._payloadVariant {
            case .decoded?: try {
                guard case .decoded(let v)? = _storage._payloadVariant else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
            }()
            case .encrypted?: try {
                guard case .encrypted(let v)? = _storage._payloadVariant else { preconditionFailure() }
                try visitor.visitSingularBytesField(value: v, fieldNumber: 5)
            }()
            case nil: break
            }
            if _storage._id != 0 {
                try visitor.visitSingularFixed32Field(value: _storage._id, fieldNumber: 6)
            }
            if _storage._rxTime != 0 {
                try visitor.visitSingularFixed32Field(value: _storage._rxTime, fieldNumber: 7)
            }
            if _storage._rxSnr != 0 {
                try visitor.visitSingularFloatField(value: _storage._rxSnr, fieldNumber: 8)
            }
            if _storage._hopLimit != 0 {
                try visitor.visitSingularUInt32Field(value: _storage._hopLimit, fieldNumber: 10)
            }
            if _storage._wantAck != false {
                try visitor.visitSingularBoolField(value: _storage._wantAck, fieldNumber: 11)
            }
            if _storage._priority != .unset {
                try visitor.visitSingularEnumField(value: _storage._priority, fieldNumber: 12)
            }
            if _storage._rxRssi != 0 {
                try visitor.visitSingularInt32Field(value: _storage._rxRssi, fieldNumber: 13)
            }
            if _storage._delayed != .noDelay {
                try visitor.visitSingularEnumField(value: _storage._delayed, fieldNumber: 15)
            }
        }
        try unknownFields.traverse(visitor: &visitor)
    }
    
    static func ==(lhs: MeshPacket, rhs: MeshPacket) -> Bool {
        if lhs._storage !== rhs._storage {
            let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
                let _storage = _args.0
                let rhs_storage = _args.1
                if _storage._from != rhs_storage._from {return false}
                if _storage._to != rhs_storage._to {return false}
                if _storage._channel != rhs_storage._channel {return false}
                if _storage._payloadVariant != rhs_storage._payloadVariant {return false}
                if _storage._id != rhs_storage._id {return false}
                if _storage._rxTime != rhs_storage._rxTime {return false}
                if _storage._rxSnr != rhs_storage._rxSnr {return false}
                if _storage._hopLimit != rhs_storage._hopLimit {return false}
                if _storage._wantAck != rhs_storage._wantAck {return false}
                if _storage._priority != rhs_storage._priority {return false}
                if _storage._rxRssi != rhs_storage._rxRssi {return false}
                if _storage._delayed != rhs_storage._delayed {return false}
                return true
            }
            if !storagesAreEqual {return false}
        }
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension MeshPacket.Priority: SwiftProtobuf._ProtoNameProviding {
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "UNSET"),
        1: .same(proto: "MIN"),
        10: .same(proto: "BACKGROUND"),
        64: .same(proto: "DEFAULT"),
        70: .same(proto: "RELIABLE"),
        120: .same(proto: "ACK"),
        127: .same(proto: "MAX"),
    ]
}

extension MeshPacket.Delayed: SwiftProtobuf._ProtoNameProviding {
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "NO_DELAY"),
        1: .same(proto: "DELAYED_BROADCAST"),
        2: .same(proto: "DELAYED_DIRECT"),
    ]
}

extension NodeInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = "NodeInfo"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "num"),
        2: .same(proto: "user"),
        3: .same(proto: "position"),
        7: .same(proto: "snr"),
        4: .standard(proto: "last_heard"),
    ]
    
    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularUInt32Field(value: &self.num) }()
            case 2: try { try decoder.decodeSingularMessageField(value: &self._user) }()
            case 3: try { try decoder.decodeSingularMessageField(value: &self._position) }()
            case 4: try { try decoder.decodeSingularFixed32Field(value: &self.lastHeard) }()
            case 7: try { try decoder.decodeSingularFloatField(value: &self.snr) }()
            default: break
            }
        }
    }
    
    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if self.num != 0 {
            try visitor.visitSingularUInt32Field(value: self.num, fieldNumber: 1)
        }
        try { if let v = self._user {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        try { if let v = self._position {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
        } }()
        if self.lastHeard != 0 {
            try visitor.visitSingularFixed32Field(value: self.lastHeard, fieldNumber: 4)
        }
        if self.snr != 0 {
            try visitor.visitSingularFloatField(value: self.snr, fieldNumber: 7)
        }
        try unknownFields.traverse(visitor: &visitor)
    }
    
    static func ==(lhs: NodeInfo, rhs: NodeInfo) -> Bool {
        if lhs.num != rhs.num {return false}
        if lhs._user != rhs._user {return false}
        if lhs._position != rhs._position {return false}
        if lhs.snr != rhs.snr {return false}
        if lhs.lastHeard != rhs.lastHeard {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension MyNodeInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = "MyNodeInfo"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "my_node_num"),
        2: .standard(proto: "has_gps"),
        3: .standard(proto: "num_bands"),
        15: .standard(proto: "max_channels"),
        4: .same(proto: "region"),
        5: .standard(proto: "hw_model_deprecated"),
        6: .standard(proto: "firmware_version"),
        7: .standard(proto: "error_code"),
        8: .standard(proto: "error_address"),
        9: .standard(proto: "error_count"),
        10: .standard(proto: "reboot_count"),
        11: .same(proto: "bitrate"),
        13: .standard(proto: "message_timeout_msec"),
        14: .standard(proto: "min_app_version"),
        16: .standard(proto: "air_period_tx"),
        17: .standard(proto: "air_period_rx"),
        18: .standard(proto: "has_wifi"),
        19: .standard(proto: "channel_utilization"),
        20: .standard(proto: "air_util_tx"),
    ]
    
    fileprivate class _StorageClass {
        var _myNodeNum: UInt32 = 0
        var _hasGps_p: Bool = false
        var _numBands: UInt32 = 0
        var _maxChannels: UInt32 = 0
        var _region: String = String()
        var _hwModelDeprecated: String = String()
        var _firmwareVersion: String = String()
        var _errorCode: CriticalErrorCode = .none
        var _errorAddress: UInt32 = 0
        var _errorCount: UInt32 = 0
        var _rebootCount: UInt32 = 0
        var _bitrate: Float = 0
        var _messageTimeoutMsec: UInt32 = 0
        var _minAppVersion: UInt32 = 0
        var _airPeriodTx: [UInt32] = []
        var _airPeriodRx: [UInt32] = []
        var _hasWifi_p: Bool = false
        var _channelUtilization: Float = 0
        var _airUtilTx: Float = 0
        
        static let defaultInstance = _StorageClass()
        
        private init() {}
        
        init(copying source: _StorageClass) {
            _myNodeNum = source._myNodeNum
            _hasGps_p = source._hasGps_p
            _numBands = source._numBands
            _maxChannels = source._maxChannels
            _region = source._region
            _hwModelDeprecated = source._hwModelDeprecated
            _firmwareVersion = source._firmwareVersion
            _errorCode = source._errorCode
            _errorAddress = source._errorAddress
            _errorCount = source._errorCount
            _rebootCount = source._rebootCount
            _bitrate = source._bitrate
            _messageTimeoutMsec = source._messageTimeoutMsec
            _minAppVersion = source._minAppVersion
            _airPeriodTx = source._airPeriodTx
            _airPeriodRx = source._airPeriodRx
            _hasWifi_p = source._hasWifi_p
            _channelUtilization = source._channelUtilization
            _airUtilTx = source._airUtilTx
        }
    }
    
    fileprivate mutating func _uniqueStorage() -> _StorageClass {
        if !isKnownUniquelyReferenced(&_storage) {
            _storage = _StorageClass(copying: _storage)
        }
        return _storage
    }
    
    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        _ = _uniqueStorage()
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            while let fieldNumber = try decoder.nextFieldNumber() {
                // The use of inline closures is to circumvent an issue where the compiler
                // allocates stack space for every case branch when no optimizations are
                // enabled. https://github.com/apple/swift-protobuf/issues/1034
                switch fieldNumber {
                case 1: try { try decoder.decodeSingularUInt32Field(value: &_storage._myNodeNum) }()
                case 2: try { try decoder.decodeSingularBoolField(value: &_storage._hasGps_p) }()
                case 3: try { try decoder.decodeSingularUInt32Field(value: &_storage._numBands) }()
                case 4: try { try decoder.decodeSingularStringField(value: &_storage._region) }()
                case 5: try { try decoder.decodeSingularStringField(value: &_storage._hwModelDeprecated) }()
                case 6: try { try decoder.decodeSingularStringField(value: &_storage._firmwareVersion) }()
                case 7: try { try decoder.decodeSingularEnumField(value: &_storage._errorCode) }()
                case 8: try { try decoder.decodeSingularUInt32Field(value: &_storage._errorAddress) }()
                case 9: try { try decoder.decodeSingularUInt32Field(value: &_storage._errorCount) }()
                case 10: try { try decoder.decodeSingularUInt32Field(value: &_storage._rebootCount) }()
                case 11: try { try decoder.decodeSingularFloatField(value: &_storage._bitrate) }()
                case 13: try { try decoder.decodeSingularUInt32Field(value: &_storage._messageTimeoutMsec) }()
                case 14: try { try decoder.decodeSingularUInt32Field(value: &_storage._minAppVersion) }()
                case 15: try { try decoder.decodeSingularUInt32Field(value: &_storage._maxChannels) }()
                case 16: try { try decoder.decodeRepeatedUInt32Field(value: &_storage._airPeriodTx) }()
                case 17: try { try decoder.decodeRepeatedUInt32Field(value: &_storage._airPeriodRx) }()
                case 18: try { try decoder.decodeSingularBoolField(value: &_storage._hasWifi_p) }()
                case 19: try { try decoder.decodeSingularFloatField(value: &_storage._channelUtilization) }()
                case 20: try { try decoder.decodeSingularFloatField(value: &_storage._airUtilTx) }()
                default: break
                }
            }
        }
    }
    
    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            if _storage._myNodeNum != 0 {
                try visitor.visitSingularUInt32Field(value: _storage._myNodeNum, fieldNumber: 1)
            }
            if _storage._hasGps_p != false {
                try visitor.visitSingularBoolField(value: _storage._hasGps_p, fieldNumber: 2)
            }
            if _storage._numBands != 0 {
                try visitor.visitSingularUInt32Field(value: _storage._numBands, fieldNumber: 3)
            }
            if !_storage._region.isEmpty {
                try visitor.visitSingularStringField(value: _storage._region, fieldNumber: 4)
            }
            if !_storage._hwModelDeprecated.isEmpty {
                try visitor.visitSingularStringField(value: _storage._hwModelDeprecated, fieldNumber: 5)
            }
            if !_storage._firmwareVersion.isEmpty {
                try visitor.visitSingularStringField(value: _storage._firmwareVersion, fieldNumber: 6)
            }
            if _storage._errorCode != .none {
                try visitor.visitSingularEnumField(value: _storage._errorCode, fieldNumber: 7)
            }
            if _storage._errorAddress != 0 {
                try visitor.visitSingularUInt32Field(value: _storage._errorAddress, fieldNumber: 8)
            }
            if _storage._errorCount != 0 {
                try visitor.visitSingularUInt32Field(value: _storage._errorCount, fieldNumber: 9)
            }
            if _storage._rebootCount != 0 {
                try visitor.visitSingularUInt32Field(value: _storage._rebootCount, fieldNumber: 10)
            }
            if _storage._bitrate != 0 {
                try visitor.visitSingularFloatField(value: _storage._bitrate, fieldNumber: 11)
            }
            if _storage._messageTimeoutMsec != 0 {
                try visitor.visitSingularUInt32Field(value: _storage._messageTimeoutMsec, fieldNumber: 13)
            }
            if _storage._minAppVersion != 0 {
                try visitor.visitSingularUInt32Field(value: _storage._minAppVersion, fieldNumber: 14)
            }
            if _storage._maxChannels != 0 {
                try visitor.visitSingularUInt32Field(value: _storage._maxChannels, fieldNumber: 15)
            }
            if !_storage._airPeriodTx.isEmpty {
                try visitor.visitPackedUInt32Field(value: _storage._airPeriodTx, fieldNumber: 16)
            }
            if !_storage._airPeriodRx.isEmpty {
                try visitor.visitPackedUInt32Field(value: _storage._airPeriodRx, fieldNumber: 17)
            }
            if _storage._hasWifi_p != false {
                try visitor.visitSingularBoolField(value: _storage._hasWifi_p, fieldNumber: 18)
            }
            if _storage._channelUtilization != 0 {
                try visitor.visitSingularFloatField(value: _storage._channelUtilization, fieldNumber: 19)
            }
            if _storage._airUtilTx != 0 {
                try visitor.visitSingularFloatField(value: _storage._airUtilTx, fieldNumber: 20)
            }
        }
        try unknownFields.traverse(visitor: &visitor)
    }
    
    static func ==(lhs: MyNodeInfo, rhs: MyNodeInfo) -> Bool {
        if lhs._storage !== rhs._storage {
            let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
                let _storage = _args.0
                let rhs_storage = _args.1
                if _storage._myNodeNum != rhs_storage._myNodeNum {return false}
                if _storage._hasGps_p != rhs_storage._hasGps_p {return false}
                if _storage._numBands != rhs_storage._numBands {return false}
                if _storage._maxChannels != rhs_storage._maxChannels {return false}
                if _storage._region != rhs_storage._region {return false}
                if _storage._hwModelDeprecated != rhs_storage._hwModelDeprecated {return false}
                if _storage._firmwareVersion != rhs_storage._firmwareVersion {return false}
                if _storage._errorCode != rhs_storage._errorCode {return false}
                if _storage._errorAddress != rhs_storage._errorAddress {return false}
                if _storage._errorCount != rhs_storage._errorCount {return false}
                if _storage._rebootCount != rhs_storage._rebootCount {return false}
                if _storage._bitrate != rhs_storage._bitrate {return false}
                if _storage._messageTimeoutMsec != rhs_storage._messageTimeoutMsec {return false}
                if _storage._minAppVersion != rhs_storage._minAppVersion {return false}
                if _storage._airPeriodTx != rhs_storage._airPeriodTx {return false}
                if _storage._airPeriodRx != rhs_storage._airPeriodRx {return false}
                if _storage._hasWifi_p != rhs_storage._hasWifi_p {return false}
                if _storage._channelUtilization != rhs_storage._channelUtilization {return false}
                if _storage._airUtilTx != rhs_storage._airUtilTx {return false}
                return true
            }
            if !storagesAreEqual {return false}
        }
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension LogRecord: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = "LogRecord"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "message"),
        2: .same(proto: "time"),
        3: .same(proto: "source"),
        4: .same(proto: "level"),
    ]
    
    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.message) }()
            case 2: try { try decoder.decodeSingularFixed32Field(value: &self.time) }()
            case 3: try { try decoder.decodeSingularStringField(value: &self.source) }()
            case 4: try { try decoder.decodeSingularEnumField(value: &self.level) }()
            default: break
            }
        }
    }
    
    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !self.message.isEmpty {
            try visitor.visitSingularStringField(value: self.message, fieldNumber: 1)
        }
        if self.time != 0 {
            try visitor.visitSingularFixed32Field(value: self.time, fieldNumber: 2)
        }
        if !self.source.isEmpty {
            try visitor.visitSingularStringField(value: self.source, fieldNumber: 3)
        }
        if self.level != .unset {
            try visitor.visitSingularEnumField(value: self.level, fieldNumber: 4)
        }
        try unknownFields.traverse(visitor: &visitor)
    }
    
    static func ==(lhs: LogRecord, rhs: LogRecord) -> Bool {
        if lhs.message != rhs.message {return false}
        if lhs.time != rhs.time {return false}
        if lhs.source != rhs.source {return false}
        if lhs.level != rhs.level {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension LogRecord.Level: SwiftProtobuf._ProtoNameProviding {
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "UNSET"),
        5: .same(proto: "TRACE"),
        10: .same(proto: "DEBUG"),
        20: .same(proto: "INFO"),
        30: .same(proto: "WARNING"),
        40: .same(proto: "ERROR"),
        50: .same(proto: "CRITICAL"),
    ]
}

extension FromRadio: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = "FromRadio"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "num"),
        11: .same(proto: "packet"),
        3: .standard(proto: "my_info"),
        4: .standard(proto: "node_info"),
        7: .standard(proto: "log_record"),
        8: .standard(proto: "config_complete_id"),
        9: .same(proto: "rebooted"),
    ]
    
    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularUInt32Field(value: &self.num) }()
            case 3: try {
                var v: MyNodeInfo?
                var hadOneofValue = false
                if let current = self.payloadVariant {
                    hadOneofValue = true
                    if case .myInfo(let m) = current {v = m}
                }
                try decoder.decodeSingularMessageField(value: &v)
                if let v = v {
                    if hadOneofValue {try decoder.handleConflictingOneOf()}
                    self.payloadVariant = .myInfo(v)
                }
            }()
            case 4: try {
                var v: NodeInfo?
                var hadOneofValue = false
                if let current = self.payloadVariant {
                    hadOneofValue = true
                    if case .nodeInfo(let m) = current {v = m}
                }
                try decoder.decodeSingularMessageField(value: &v)
                if let v = v {
                    if hadOneofValue {try decoder.handleConflictingOneOf()}
                    self.payloadVariant = .nodeInfo(v)
                }
            }()
            case 7: try {
                var v: LogRecord?
                var hadOneofValue = false
                if let current = self.payloadVariant {
                    hadOneofValue = true
                    if case .logRecord(let m) = current {v = m}
                }
                try decoder.decodeSingularMessageField(value: &v)
                if let v = v {
                    if hadOneofValue {try decoder.handleConflictingOneOf()}
                    self.payloadVariant = .logRecord(v)
                }
            }()
            case 8: try {
                var v: UInt32?
                try decoder.decodeSingularUInt32Field(value: &v)
                if let v = v {
                    if self.payloadVariant != nil {try decoder.handleConflictingOneOf()}
                    self.payloadVariant = .configCompleteID(v)
                }
            }()
            case 9: try {
                var v: Bool?
                try decoder.decodeSingularBoolField(value: &v)
                if let v = v {
                    if self.payloadVariant != nil {try decoder.handleConflictingOneOf()}
                    self.payloadVariant = .rebooted(v)
                }
            }()
            case 11: try {
                var v: MeshPacket?
                var hadOneofValue = false
                if let current = self.payloadVariant {
                    hadOneofValue = true
                    if case .packet(let m) = current {v = m}
                }
                try decoder.decodeSingularMessageField(value: &v)
                if let v = v {
                    if hadOneofValue {try decoder.handleConflictingOneOf()}
                    self.payloadVariant = .packet(v)
                }
            }()
            default: break
            }
        }
    }
    
    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if self.num != 0 {
            try visitor.visitSingularUInt32Field(value: self.num, fieldNumber: 1)
        }
        switch self.payloadVariant {
        case .myInfo?: try {
            guard case .myInfo(let v)? = self.payloadVariant else { preconditionFailure() }
            try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
        }()
        case .nodeInfo?: try {
            guard case .nodeInfo(let v)? = self.payloadVariant else { preconditionFailure() }
            try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
        }()
        case .logRecord?: try {
            guard case .logRecord(let v)? = self.payloadVariant else { preconditionFailure() }
            try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
        }()
        case .configCompleteID?: try {
            guard case .configCompleteID(let v)? = self.payloadVariant else { preconditionFailure() }
            try visitor.visitSingularUInt32Field(value: v, fieldNumber: 8)
        }()
        case .rebooted?: try {
            guard case .rebooted(let v)? = self.payloadVariant else { preconditionFailure() }
            try visitor.visitSingularBoolField(value: v, fieldNumber: 9)
        }()
        case .packet?: try {
            guard case .packet(let v)? = self.payloadVariant else { preconditionFailure() }
            try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
        }()
        case nil: break
        }
        try unknownFields.traverse(visitor: &visitor)
    }
    
    static func ==(lhs: FromRadio, rhs: FromRadio) -> Bool {
        if lhs.num != rhs.num {return false}
        if lhs.payloadVariant != rhs.payloadVariant {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension ToRadio: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = "ToRadio"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        2: .same(proto: "packet"),
        3: .standard(proto: "peer_info"),
        100: .standard(proto: "want_config_id"),
        104: .same(proto: "disconnect"),
    ]
    
    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 2: try {
                var v: MeshPacket?
                var hadOneofValue = false
                if let current = self.payloadVariant {
                    hadOneofValue = true
                    if case .packet(let m) = current {v = m}
                }
                try decoder.decodeSingularMessageField(value: &v)
                if let v = v {
                    if hadOneofValue {try decoder.handleConflictingOneOf()}
                    self.payloadVariant = .packet(v)
                }
            }()
            case 3: try {
                var v: ToRadio.PeerInfo?
                var hadOneofValue = false
                if let current = self.payloadVariant {
                    hadOneofValue = true
                    if case .peerInfo(let m) = current {v = m}
                }
                try decoder.decodeSingularMessageField(value: &v)
                if let v = v {
                    if hadOneofValue {try decoder.handleConflictingOneOf()}
                    self.payloadVariant = .peerInfo(v)
                }
            }()
            case 100: try {
                var v: UInt32?
                try decoder.decodeSingularUInt32Field(value: &v)
                if let v = v {
                    if self.payloadVariant != nil {try decoder.handleConflictingOneOf()}
                    self.payloadVariant = .wantConfigID(v)
                }
            }()
            case 104: try {
                var v: Bool?
                try decoder.decodeSingularBoolField(value: &v)
                if let v = v {
                    if self.payloadVariant != nil {try decoder.handleConflictingOneOf()}
                    self.payloadVariant = .disconnect(v)
                }
            }()
            default: break
            }
        }
    }
    
    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        switch self.payloadVariant {
        case .packet?: try {
            guard case .packet(let v)? = self.payloadVariant else { preconditionFailure() }
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        }()
        case .peerInfo?: try {
            guard case .peerInfo(let v)? = self.payloadVariant else { preconditionFailure() }
            try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
        }()
        case .wantConfigID?: try {
            guard case .wantConfigID(let v)? = self.payloadVariant else { preconditionFailure() }
            try visitor.visitSingularUInt32Field(value: v, fieldNumber: 100)
        }()
        case .disconnect?: try {
            guard case .disconnect(let v)? = self.payloadVariant else { preconditionFailure() }
            try visitor.visitSingularBoolField(value: v, fieldNumber: 104)
        }()
        case nil: break
        }
        try unknownFields.traverse(visitor: &visitor)
    }
    
    static func ==(lhs: ToRadio, rhs: ToRadio) -> Bool {
        if lhs.payloadVariant != rhs.payloadVariant {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension ToRadio.PeerInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = ToRadio.protoMessageName + ".PeerInfo"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "app_version"),
        2: .standard(proto: "mqtt_gateway"),
    ]
    
    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularUInt32Field(value: &self.appVersion) }()
            case 2: try { try decoder.decodeSingularBoolField(value: &self.mqttGateway) }()
            default: break
            }
        }
    }
    
    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if self.appVersion != 0 {
            try visitor.visitSingularUInt32Field(value: self.appVersion, fieldNumber: 1)
        }
        if self.mqttGateway != false {
            try visitor.visitSingularBoolField(value: self.mqttGateway, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }
    
    static func ==(lhs: ToRadio.PeerInfo, rhs: ToRadio.PeerInfo) -> Bool {
        if lhs.appVersion != rhs.appVersion {return false}
        if lhs.mqttGateway != rhs.mqttGateway {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}
